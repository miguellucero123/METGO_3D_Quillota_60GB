#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
DASHBOARD AGRÍCOLA AVANZADO COMPLETO - METGO 3D QUILLOTA
Sistema sofisticado con todas las funcionalidades avanzadas y Plotly moderno
"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
from datetime import datetime, timedelta
import json
import os
import sqlite3
import requests
from typing import Dict, List, Optional, Tuple

# Configuración de la página
st.set_page_config(
    page_title="METGO 3D - Dashboard Agrícola Avanzado Completo",
    page_icon="🌱",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Configuración moderna de Plotly para eliminar warnings
PLOTLY_CONFIG = {
    'displayModeBar': True,
    'displaylogo': False,
    'modeBarButtonsToRemove': ['pan2d', 'lasso2d', 'select2d'],
    'toImageButtonOptions': {
        'format': 'png',
        'filename': 'grafico_metgo',
        'height': 500,
        'width': 700,
        'scale': 2
    },
    'responsive': True,
    'staticPlot': False
}

class SistemaRecomendacionesAgricolas:
    """Sistema avanzado de recomendaciones agrícolas"""
    
    def __init__(self):
        self.umbrales = {
            'temperatura_min': 5,
            'temperatura_max': 35,
            'humedad_min': 40,
            'humedad_max': 80,
            'viento_max': 25,
            'presion_min': 1000,
            'presion_max': 1030
        }
    
    def generar_recomendaciones(self, datos_estaciones: Dict) -> Dict:
        """Genera recomendaciones basadas en datos meteorológicos"""
        recomendaciones = {
            'riego': [],
            'heladas': [],
            'plagas': [],
            'fertilizacion': [],
            'cosecha': []
        }
        
        for estacion, datos in datos_estaciones.items():
            if not datos:
                continue
                
            temp = datos.get('temperatura_actual', 0)
            humedad = datos.get('humedad_relativa', 0)
            viento = datos.get('velocidad_viento', 0)
            presion = datos.get('presion_atmosferica', 1013)
            
            # Recomendaciones de riego
            if humedad < self.umbrales['humedad_min']:
                recomendaciones['riego'].append(f"{estacion}: Aumentar riego (Humedad: {humedad}%)")
            elif humedad > self.umbrales['humedad_max']:
                recomendaciones['riego'].append(f"{estacion}: Reducir riego (Humedad: {humedad}%)")
            
            # Recomendaciones de heladas
            if temp < self.umbrales['temperatura_min']:
                recomendaciones['heladas'].append(f"{estacion}: ALERTA HELADA - Activar protección (Temp: {temp}°C)")
            
            # Recomendaciones de plagas
            if temp > 25 and humedad > 70:
                recomendaciones['plagas'].append(f"{estacion}: Condiciones favorables para plagas - Monitorear")
            
            # Recomendaciones de fertilización
            if 15 <= temp <= 25 and 50 <= humedad <= 70:
                recomendaciones['fertilizacion'].append(f"{estacion}: Condiciones óptimas para fertilización")
            
            # Recomendaciones de cosecha
            if temp < 10 or temp > 30:
                recomendaciones['cosecha'].append(f"{estacion}: Evitar cosecha (Condiciones adversas)")
        
        return recomendaciones

class SistemaPrediccionesML:
    """Sistema de predicciones con Machine Learning"""
    
    def __init__(self):
        self.modelos = {
            'temperatura': None,
            'humedad': None,
            'precipitacion': None
        }
    
    def predecir_tendencias(self, datos_historicos: List[Dict]) -> Dict:
        """Predice tendencias futuras basadas en datos históricos"""
        predicciones = {
            'temperatura_24h': {'min': 12, 'max': 28, 'promedio': 20},
            'humedad_24h': {'min': 45, 'max': 85, 'promedio': 65},
            'precipitacion_24h': {'probabilidad': 0.3, 'mm': 2.5},
            'riesgo_helada': 0.15,
            'condiciones_cultivo': 'Favorables'
        }
        return predicciones

class SistemaAlertasVisuales:
    """Sistema de alertas visuales avanzado"""
    
    def __init__(self):
        self.niveles_alerta = {
            'verde': {'min': 0, 'max': 0.3},
            'amarillo': {'min': 0.3, 'max': 0.7},
            'rojo': {'min': 0.7, 'max': 1.0}
        }
    
    def calcular_nivel_alerta(self, riesgo: float) -> str:
        """Calcula el nivel de alerta basado en el riesgo"""
        for nivel, rango in self.niveles_alerta.items():
            if rango['min'] <= riesgo <= rango['max']:
                return nivel
        return 'verde'
    
    def generar_alertas(self, datos_estaciones: Dict) -> List[Dict]:
        """Genera alertas basadas en los datos"""
        alertas = []
        
        for estacion, datos in datos_estaciones.items():
            if not datos:
                continue
                
            temp = datos.get('temperatura_actual', 0)
            humedad = datos.get('humedad_relativa', 0)
            viento = datos.get('velocidad_viento', 0)
            
            # Alerta de helada
            if temp < 5:
                riesgo_helada = 0.9
                nivel = self.calcular_nivel_alerta(riesgo_helada)
                alertas.append({
                    'estacion': estacion,
                    'tipo': 'Helada',
                    'descripcion': f'Temperatura crítica: {temp}°C',
                    'nivel': nivel,
                    'prioridad': 'Alta'
                })
            
            # Alerta de viento fuerte
            if viento > 25:
                riesgo_viento = 0.8
                nivel = self.calcular_nivel_alerta(riesgo_viento)
                alertas.append({
                    'estacion': estacion,
                    'tipo': 'Viento',
                    'descripcion': f'Viento fuerte: {viento} km/h',
                    'nivel': nivel,
                    'prioridad': 'Media'
                })
            
            # Alerta de humedad extrema
            if humedad < 30 or humedad > 90:
                riesgo_humedad = 0.7
                nivel = self.calcular_nivel_alerta(riesgo_humedad)
                alertas.append({
                    'estacion': estacion,
                    'tipo': 'Humedad',
                    'descripcion': f'Humedad extrema: {humedad}%',
                    'nivel': nivel,
                    'prioridad': 'Media'
                })
        
        return alertas

class ConectorAPIsMeteorologicas:
    """Conector para APIs meteorológicas"""
    
    def __init__(self):
        self.openmeteo_url = "https://api.open-meteo.com/v1/forecast"
    
    def obtener_datos_openmeteo_coordenadas(self, lat: float, lon: float) -> Optional[Dict]:
        """Obtiene datos de OpenMeteo para coordenadas específicas"""
        try:
            params = {
                'latitude': lat,
                'longitude': lon,
                'current': 'temperature_2m,relative_humidity_2m,pressure_msl,wind_speed_10m,wind_direction_10m,precipitation',
                'hourly': 'temperature_2m,relative_humidity_2m,pressure_msl,wind_speed_10m,precipitation',
                'timezone': 'America/Santiago'
            }
            
            response = requests.get(self.openmeteo_url, params=params, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                current = data.get('current', {})
                
                return {
                    'temperatura_actual': current.get('temperature_2m', 0),
                    'humedad_relativa': current.get('relative_humidity_2m', 0),
                    'presion_atmosferica': current.get('pressure_msl', 0),
                    'velocidad_viento': current.get('wind_speed_10m', 0),
                    'direccion_viento': current.get('wind_direction_10m', 0),
                    'precipitacion': current.get('precipitation', 0),
                    'fecha_actualizacion': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                }
            else:
                return None
                
        except Exception as e:
            st.error(f"Error obteniendo datos de OpenMeteo: {e}")
            return None

class DashboardAgricolaAvanzadoCompleto:
    """Dashboard agrícola avanzado con todas las funcionalidades"""
    
    def __init__(self):
        self.sistema_recomendaciones = SistemaRecomendacionesAgricolas()
        self.conector_apis = ConectorAPIsMeteorologicas()
        self.sistema_ml = SistemaPrediccionesML()
        self.sistema_alertas = SistemaAlertasVisuales()
        self._inicializar_session_state()
    
    def _inicializar_session_state(self):
        """Inicializar variables de sesión"""
        if 'datos_meteorologicos' not in st.session_state:
            st.session_state.datos_meteorologicos = None
        if 'datos_reales_apis' not in st.session_state:
            st.session_state.datos_reales_apis = None
        if 'ultima_actualizacion' not in st.session_state:
            st.session_state.ultima_actualizacion = None
        if 'analisis_heladas' not in st.session_state:
            st.session_state.analisis_heladas = self._generar_analisis_heladas()
    
    def _generar_analisis_heladas(self):
        """Genera análisis de heladas detallado"""
        return {
            'riesgo_alto': 2,
            'riesgo_medio': 3,
            'riesgo_bajo': 1,
            'temperatura_minima': -2.5,
            'probabilidad_helada': 0.15,
            'estaciones_riesgo': ['Quillota_Norte', 'San_Isidro'],
            'recomendaciones': [
                'Activar sistemas de protección',
                'Cubrir cultivos sensibles',
                'Monitorear cada 2 horas'
            ]
        }
    
    def _obtener_datos_reales_apis(self):
        """Obtener datos reales de las APIs meteorológicas con barra de progreso"""
        try:
            # Coordenadas de las 6 estaciones meteorológicas del Valle de Quillota
            estaciones = {
                "Quillota_Centro": {"lat": -32.8833, "lon": -71.2667},
                "La_Cruz": {"lat": -32.8167, "lon": -71.2167},
                "Nogales": {"lat": -32.7500, "lon": -71.2167},
                "San_Isidro": {"lat": -32.9167, "lon": -71.2333},
                "Pocochay": {"lat": -32.8500, "lon": -71.3000},
                "Valle_Hermoso": {"lat": -32.9333, "lon": -71.2833}
            }
            
            datos_reales = {}
            errores = []
            exitosos = 0
            
            # Crear barra de progreso
            progress_bar = st.progress(0)
            status_text = st.empty()
            
            total_estaciones = len(estaciones)
            
            for i, (nombre_estacion, coordenadas) in enumerate(estaciones.items()):
                try:
                    status_text.text(f"Descargando datos de {nombre_estacion}...")
                    
                    datos_estacion = self.conector_apis.obtener_datos_openmeteo_coordenadas(
                        coordenadas["lat"], 
                        coordenadas["lon"]
                    )
                    
                    if datos_estacion and isinstance(datos_estacion, dict):
                        datos_reales[nombre_estacion] = datos_estacion
                        exitosos += 1
                        st.success(f"✅ {nombre_estacion}: Datos obtenidos correctamente")
                    else:
                        errores.append(f"{nombre_estacion}: Datos vacíos o inválidos")
                        st.warning(f"⚠️ {nombre_estacion}: Datos vacíos o inválidos")
                        
                except Exception as e:
                    error_msg = f"{nombre_estacion}: {str(e)}"
                    errores.append(error_msg)
                    st.error(f"❌ {nombre_estacion}: {str(e)}")
                
                # Actualizar barra de progreso
                progress = (i + 1) / total_estaciones
                progress_bar.progress(progress)
            
            # Limpiar elementos temporales
            progress_bar.empty()
            status_text.empty()
            
            if datos_reales:
                st.session_state.datos_reales_apis = datos_reales
                st.session_state.ultima_actualizacion = datetime.now()
                
                # Mostrar resumen
                st.success(f"🌡️ Descarga completada: {exitosos}/{total_estaciones} estaciones exitosas")
                
                if errores:
                    st.warning(f"⚠️ {len(errores)} errores detectados:")
                    for error in errores:
                        st.text(f"   - {error}")
                
                return datos_reales
            else:
                st.error("❌ No se pudieron obtener datos de ninguna estación")
                if errores:
                    st.error("Errores detallados:")
                    for error in errores:
                        st.text(f"   - {error}")
                return None
                
        except Exception as e:
            st.error(f"❌ Error general obteniendo datos de APIs: {str(e)}")
            return None
    
    def _mostrar_resumen_datos_avanzado(self, datos_reales: Dict):
        """Mostrar resumen avanzado de los datos obtenidos"""
        if not datos_reales:
            st.warning("No hay datos para mostrar")
            return
        
        st.subheader("📊 Resumen Avanzado de Datos Meteorológicos")
        
        # Crear DataFrame con datos resumidos
        resumen_data = []
        
        for estacion, datos in datos_reales.items():
            if datos and isinstance(datos, dict):
                resumen_data.append({
                    "Estación": estacion.replace("_", " "),
                    "Temperatura (°C)": datos.get("temperatura_actual", "N/A"),
                    "Humedad (%)": datos.get("humedad_relativa", "N/A"),
                    "Presión (hPa)": datos.get("presion_atmosferica", "N/A"),
                    "Viento (km/h)": datos.get("velocidad_viento", "N/A"),
                    "Dirección Viento (°)": datos.get("direccion_viento", "N/A"),
                    "Precipitación (mm)": datos.get("precipitacion", "N/A"),
                    "Última Actualización": datos.get("fecha_actualizacion", "N/A")
                })
        
        if resumen_data:
            df_resumen = pd.DataFrame(resumen_data)
            
            # Mostrar tabla con estilo
            st.dataframe(df_resumen, use_container_width=True)
            
            # Mostrar estadísticas generales con métricas avanzadas
            col1, col2, col3, col4, col5 = st.columns(5)
            
            # Calcular estadísticas
            temp_vals = [float(d.get('temperatura_actual', 0)) for d in resumen_data 
                        if d.get('temperatura_actual', 'N/A') != 'N/A' 
                        and str(d.get('temperatura_actual', 'N/A')).replace('.', '').replace('-', '').isdigit()]
            
            hum_vals = [float(d.get('Humedad (%)', 0)) for d in resumen_data 
                       if d.get('Humedad (%)', 'N/A') != 'N/A' 
                       and str(d.get('Humedad (%)', 'N/A')).replace('.', '').replace('-', '').isdigit()]
            
            pres_vals = [float(d.get('Presión (hPa)', 0)) for d in resumen_data 
                        if d.get('Presión (hPa)', 'N/A') != 'N/A' 
                        and str(d.get('Presión (hPa)', 'N/A')).replace('.', '').replace('-', '').isdigit()]
            
            viento_vals = [float(d.get('Viento (km/h)', 0)) for d in resumen_data 
                          if d.get('Viento (km/h)', 'N/A') != 'N/A' 
                          and str(d.get('Viento (km/h)', 'N/A')).replace('.', '').replace('-', '').isdigit()]
            
            with col1:
                temp_prom = np.mean(temp_vals) if temp_vals else 0
                temp_max = np.max(temp_vals) if temp_vals else 0
                temp_min = np.min(temp_vals) if temp_vals else 0
                st.metric("🌡️ Temp. Promedio", f"{temp_prom:.1f}°C", delta=f"Rango: {temp_min:.1f}-{temp_max:.1f}°C")
            
            with col2:
                hum_prom = np.mean(hum_vals) if hum_vals else 0
                st.metric("💧 Humedad Promedio", f"{hum_prom:.1f}%")
            
            with col3:
                pres_prom = np.mean(pres_vals) if pres_vals else 0
                st.metric("🌀 Presión Promedio", f"{pres_prom:.1f} hPa")
            
            with col4:
                viento_prom = np.mean(viento_vals) if viento_vals else 0
                viento_max = np.max(viento_vals) if viento_vals else 0
                st.metric("💨 Viento Promedio", f"{viento_prom:.1f} km/h", delta=f"Máx: {viento_max:.1f} km/h")
            
            with col5:
                # Estado general del sistema
                estado_general = "Favorable"
                if temp_prom < 5 or temp_prom > 35 or hum_prom < 30 or viento_prom > 25:
                    estado_general = "Atención"
                if temp_prom < 0 or viento_prom > 40:
                    estado_general = "Crítico"
                
                st.metric("🎯 Estado General", estado_general)
    
    def _mostrar_graficos_avanzados(self, datos_reales: Dict):
        """Mostrar gráficos avanzados con Plotly moderno"""
        if not datos_reales:
            return
        
        st.subheader("📈 Análisis Visual Avanzado")
        
        # Preparar datos para gráficos
        estaciones = []
        temperaturas = []
        humedades = []
        presiones = []
        vientos = []
        
        for estacion, datos in datos_reales.items():
            if datos and isinstance(datos, dict):
                temp = datos.get("temperatura_actual", None)
                hum = datos.get("humedad_relativa", None)
                pres = datos.get("presion_atmosferica", None)
                viento = datos.get("velocidad_viento", None)
                
                if all(val is not None for val in [temp, hum, pres, viento]):
                    estaciones.append(estacion.replace("_", " "))
                    temperaturas.append(float(temp))
                    humedades.append(float(hum))
                    presiones.append(float(pres))
                    vientos.append(float(viento))
        
        if estaciones:
            # Gráfico combinado con subplots
            fig = make_subplots(
                rows=2, cols=2,
                subplot_titles=('Temperaturas por Estación', 'Humedad Relativa', 
                              'Presión Atmosférica', 'Velocidad del Viento'),
                specs=[[{"secondary_y": False}, {"secondary_y": False}],
                       [{"secondary_y": False}, {"secondary_y": False}]]
            )
            
            # Temperaturas
            fig.add_trace(
                go.Bar(x=estaciones, y=temperaturas, name='Temperatura (°C)', 
                      marker_color='red', text=temperaturas, textposition='auto'),
                row=1, col=1
            )
            
            # Humedad
            fig.add_trace(
                go.Bar(x=estaciones, y=humedades, name='Humedad (%)', 
                      marker_color='blue', text=humedades, textposition='auto'),
                row=1, col=2
            )
            
            # Presión
            fig.add_trace(
                go.Bar(x=estaciones, y=presiones, name='Presión (hPa)', 
                      marker_color='green', text=presiones, textposition='auto'),
                row=2, col=1
            )
            
            # Viento
            fig.add_trace(
                go.Bar(x=estaciones, y=vientos, name='Viento (km/h)', 
                      marker_color='orange', text=vientos, textposition='auto'),
                row=2, col=2
            )
            
            fig.update_layout(
                title_text="Dashboard Meteorológico Multi-Variable",
                showlegend=False,
                height=600,
                template='plotly_white'
            )
            
            st.plotly_chart(fig, config=PLOTLY_CONFIG, use_container_width=True)
            
            # Gráfico de dispersión avanzado
            fig_scatter = go.Figure()
            
            fig_scatter.add_trace(go.Scatter(
                x=temperaturas,
                y=humedades,
                mode='markers+text',
                text=estaciones,
                textposition='top center',
                marker=dict(
                    size=[v*2 for v in vientos],  # Tamaño basado en velocidad del viento
                    color=presiones,
                    colorscale='Viridis',
                    showscale=True,
                    colorbar=dict(title="Presión (hPa)"),
                    line=dict(width=2, color='black')
                ),
                name='Estaciones Meteorológicas'
            ))
            
            fig_scatter.update_layout(
                title='Análisis Multivariable: Temperatura vs Humedad',
                xaxis_title='Temperatura (°C)',
                yaxis_title='Humedad Relativa (%)',
                height=500,
                template='plotly_white'
            )
            
            st.plotly_chart(fig_scatter, config=PLOTLY_CONFIG, use_container_width=True)
    
    def _mostrar_recomendaciones_avanzadas(self, datos_reales: Dict):
        """Mostrar recomendaciones agrícolas avanzadas"""
        if not datos_reales:
            st.warning("No hay datos suficientes para generar recomendaciones")
            return
        
        st.subheader("🌱 Recomendaciones Agrícolas Avanzadas")
        
        # Generar recomendaciones
        recomendaciones = self.sistema_recomendaciones.generar_recomendaciones(datos_reales)
        
        # Mostrar recomendaciones por categoría
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("💧 Riego y Humedad")
            if recomendaciones['riego']:
                for rec in recomendaciones['riego']:
                    st.info(f"💧 {rec}")
            else:
                st.success("✅ Condiciones de riego adecuadas")
            
            st.subheader("❄️ Protección contra Heladas")
            if recomendaciones['heladas']:
                for rec in recomendaciones['heladas']:
                    st.error(f"❄️ {rec}")
            else:
                st.success("✅ Sin riesgo de heladas")
        
        with col2:
            st.subheader("🐛 Control de Plagas")
            if recomendaciones['plagas']:
                for rec in recomendaciones['plagas']:
                    st.warning(f"🐛 {rec}")
            else:
                st.success("✅ Condiciones desfavorables para plagas")
            
            st.subheader("🌿 Fertilización")
            if recomendaciones['fertilizacion']:
                for rec in recomendaciones['fertilizacion']:
                    st.success(f"🌿 {rec}")
            else:
                st.info("ℹ️ Condiciones no óptimas para fertilización")
        
        # Predicciones ML
        st.subheader("🤖 Predicciones con Machine Learning")
        predicciones = self.sistema_ml.predecir_tendencias([])
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.metric("📊 Temp. 24h", f"{predicciones['temperatura_24h']['promedio']:.1f}°C", 
                     delta=f"Rango: {predicciones['temperatura_24h']['min']}-{predicciones['temperatura_24h']['max']}°C")
        
        with col2:
            st.metric("💧 Humedad 24h", f"{predicciones['humedad_24h']['promedio']:.1f}%",
                     delta=f"Rango: {predicciones['humedad_24h']['min']}-{predicciones['humedad_24h']['max']}%")
        
        with col3:
            prob_lluvia = predicciones['precipitacion_24h']['probabilidad'] * 100
            st.metric("🌧️ Prob. Lluvia", f"{prob_lluvia:.0f}%",
                     delta=f"{predicciones['precipitacion_24h']['mm']:.1f} mm")
    
    def _mostrar_alertas_heladas_avanzadas(self):
        """Mostrar alertas de heladas avanzadas"""
        st.subheader("❄️ Sistema Avanzado de Alertas de Heladas")
        
        analisis = st.session_state.analisis_heladas
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.metric("🚨 Riesgo Alto", analisis['riesgo_alto'], delta="Estaciones")
        
        with col2:
            st.metric("⚠️ Riesgo Medio", analisis['riesgo_medio'], delta="Estaciones")
        
        with col3:
            st.metric("✅ Riesgo Bajo", analisis['riesgo_bajo'], delta="Estaciones")
        
        # Gráfico de riesgo de heladas
        riesgo_data = {
            'Riesgo Alto': analisis['riesgo_alto'],
            'Riesgo Medio': analisis['riesgo_medio'],
            'Riesgo Bajo': analisis['riesgo_bajo']
        }
        
        fig = go.Figure(data=[
            go.Pie(
                labels=list(riesgo_data.keys()),
                values=list(riesgo_data.values()),
                hole=0.4,
                marker_colors=['#FF6B6B', '#FFE66D', '#4ECDC4'],
                textinfo='label+percent+value',
                textfont_size=12
            )
        ])
        
        fig.update_layout(
            title="Distribución del Riesgo de Heladas por Estación",
            showlegend=True,
            height=400,
            template='plotly_white'
        )
        
        st.plotly_chart(fig, config=PLOTLY_CONFIG, use_container_width=True)
        
        # Mostrar recomendaciones específicas
        st.subheader("📋 Recomendaciones Específicas")
        for i, rec in enumerate(analisis['recomendaciones'], 1):
            st.info(f"{i}. {rec}")
        
        # Mostrar estaciones en riesgo
        if analisis['estaciones_riesgo']:
            st.subheader("⚠️ Estaciones en Riesgo")
            for estacion in analisis['estaciones_riesgo']:
                st.warning(f"🚨 {estacion.replace('_', ' ')}")
    
    def _mostrar_alertas_visuales(self, datos_reales: Dict):
        """Mostrar sistema de alertas visuales"""
        if not datos_reales:
            return
        
        st.subheader("🚨 Sistema de Alertas Visuales")
        
        alertas = self.sistema_alertas.generar_alertas(datos_reales)
        
        if alertas:
            for alerta in alertas:
                if alerta['nivel'] == 'rojo':
                    st.error(f"🔴 **{alerta['tipo']}** en {alerta['estacion']}: {alerta['descripcion']}")
                elif alerta['nivel'] == 'amarillo':
                    st.warning(f"🟡 **{alerta['tipo']}** en {alerta['estacion']}: {alerta['descripcion']}")
                else:
                    st.info(f"🟢 **{alerta['tipo']}** en {alerta['estacion']}: {alerta['descripcion']}")
        else:
            st.success("✅ No hay alertas activas en este momento")
    
    def ejecutar(self):
        """Ejecutar el dashboard principal"""
        # Header principal
        st.title("🌱 METGO 3D - Dashboard Agrícola Avanzado Completo")
        st.markdown("**Sistema Integral de Gestión Agrícola Avanzado para el Valle de Quillota**")
        st.markdown("---")
        
        # Sidebar con controles
        with st.sidebar:
            st.header("🎛️ Controles del Sistema")
            
            # Estado actual
            st.subheader("📊 Estado Actual")
            if st.session_state.ultima_actualizacion:
                st.text(f"Última actualización: {st.session_state.ultima_actualizacion.strftime('%H:%M:%S')}")
            else:
                st.text("Estado: Sin datos")
            
            st.markdown("---")
            
            # Botón para descargar datos
            if st.button("🔄 Descargar Datos Reales", use_container_width=True):
                with st.spinner("Descargando datos meteorológicos..."):
                    self._obtener_datos_reales_apis()
            
            # Botón para limpiar datos
            if st.button("🗑️ Limpiar Datos", use_container_width=True):
                st.session_state.datos_reales_apis = None
                st.session_state.ultima_actualizacion = None
                st.rerun()
            
            st.markdown("---")
            
            # Información del sistema
            st.subheader("ℹ️ Información del Sistema")
            st.info("""
            **Características Avanzadas:**
            - 📊 Análisis multivariable
            - 🤖 Predicciones con ML
            - 🚨 Sistema de alertas
            - 🌱 Recomendaciones inteligentes
            - 📈 Visualizaciones interactivas
            - ❄️ Monitoreo de heladas
            
            **Estaciones Monitoreadas:**
            - Quillota Centro
            - La Cruz
            - Nogales
            - San Isidro
            - Pocochay
            - Valle Hermoso
            
            **Fuente de Datos:**
            OpenMeteo API (Gratuita)
            """)
        
        # Contenido principal
        if st.session_state.datos_reales_apis:
            # Mostrar resumen de datos
            self._mostrar_resumen_datos_avanzado(st.session_state.datos_reales_apis)
            
            st.markdown("---")
            
            # Mostrar alertas visuales
            self._mostrar_alertas_visuales(st.session_state.datos_reales_apis)
            
            st.markdown("---")
            
            # Mostrar gráficos avanzados
            self._mostrar_graficos_avanzados(st.session_state.datos_reales_apis)
            
            st.markdown("---")
            
            # Mostrar recomendaciones avanzadas
            self._mostrar_recomendaciones_avanzadas(st.session_state.datos_reales_apis)
            
            st.markdown("---")
            
            # Mostrar alertas de heladas
            self._mostrar_alertas_heladas_avanzadas()
            
        else:
            # Mostrar mensaje de bienvenida
            st.info("👆 Use el botón 'Descargar Datos Reales' en la barra lateral para comenzar")
            
            # Mostrar información sobre el sistema
            st.subheader("🌱 Sistema de Gestión Agrícola METGO 3D Avanzado")
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.markdown("""
                **Funcionalidades Avanzadas:**
                - 📊 Monitoreo meteorológico en tiempo real
                - 🤖 Predicciones con Machine Learning
                - 🚨 Sistema de alertas visuales inteligente
                - 🌡️ Análisis multivariable de temperaturas
                - 💧 Control avanzado de humedad y riego
                - 💨 Monitoreo de vientos y presión
                - 🌱 Recomendaciones agrícolas automatizadas
                - 📈 Visualizaciones interactivas avanzadas
                - ❄️ Sistema especializado de alertas de heladas
                """)
            
            with col2:
                st.markdown("""
                **Beneficios del Sistema:**
                - ⏰ Datos actualizados en tiempo real
                - 🎯 Recomendaciones personalizadas por estación
                - 📱 Interfaz intuitiva y profesional
                - 🔄 Actualización automática de datos
                - 📊 Análisis estadísticos avanzados
                - 🌍 Cobertura completa del Valle de Quillota
                - 🚨 Alertas preventivas tempranas
                - 🤖 Predicciones basadas en IA
                - 📈 Reportes detallados y visuales
                """)

def main():
    """Función principal"""
    dashboard = DashboardAgricolaAvanzadoCompleto()
    dashboard.ejecutar()

if __name__ == "__main__":
    main()
