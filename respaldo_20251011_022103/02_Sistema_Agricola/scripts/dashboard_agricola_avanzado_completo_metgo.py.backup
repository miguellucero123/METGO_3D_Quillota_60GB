#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
DASHBOARD AGR√çCOLA AVANZADO COMPLETO - METGO 3D QUILLOTA
Sistema sofisticado con todas las funcionalidades avanzadas y Plotly moderno
"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
from datetime import datetime, timedelta
import json
import os
import sqlite3
import requests
from typing import Dict, List, Optional, Tuple

# Configuraci√≥n de la p√°gina
st.set_page_config(
    page_title="METGO 3D - Dashboard Agr√≠cola Avanzado Completo",
    page_icon="üå±",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Configuraci√≥n moderna de Plotly para eliminar warnings
PLOTLY_CONFIG = {
    'displayModeBar': True,
    'displaylogo': False,
    'modeBarButtonsToRemove': ['pan2d', 'lasso2d', 'select2d'],
    'toImageButtonOptions': {
        'format': 'png',
        'filename': 'grafico_metgo',
        'height': 500,
        'width': 700,
        'scale': 2
    },
    'responsive': True,
    'staticPlot': False
}

class SistemaRecomendacionesAgricolas:
    """Sistema avanzado de recomendaciones agr√≠colas"""
    
    def __init__(self):
        self.umbrales = {
            'temperatura_min': 5,
            'temperatura_max': 35,
            'humedad_min': 40,
            'humedad_max': 80,
            'viento_max': 25,
            'presion_min': 1000,
            'presion_max': 1030
        }
    
    def generar_recomendaciones(self, datos_estaciones: Dict) -> Dict:
        """Genera recomendaciones basadas en datos meteorol√≥gicos"""
        recomendaciones = {
            'riego': [],
            'heladas': [],
            'plagas': [],
            'fertilizacion': [],
            'cosecha': []
        }
        
        for estacion, datos in datos_estaciones.items():
            if not datos:
                continue
                
            temp = datos.get('temperatura_actual', 0)
            humedad = datos.get('humedad_relativa', 0)
            viento = datos.get('velocidad_viento', 0)
            presion = datos.get('presion_atmosferica', 1013)
            
            # Recomendaciones de riego
            if humedad < self.umbrales['humedad_min']:
                recomendaciones['riego'].append(f"{estacion}: Aumentar riego (Humedad: {humedad}%)")
            elif humedad > self.umbrales['humedad_max']:
                recomendaciones['riego'].append(f"{estacion}: Reducir riego (Humedad: {humedad}%)")
            
            # Recomendaciones de heladas
            if temp < self.umbrales['temperatura_min']:
                recomendaciones['heladas'].append(f"{estacion}: ALERTA HELADA - Activar protecci√≥n (Temp: {temp}¬∞C)")
            
            # Recomendaciones de plagas
            if temp > 25 and humedad > 70:
                recomendaciones['plagas'].append(f"{estacion}: Condiciones favorables para plagas - Monitorear")
            
            # Recomendaciones de fertilizaci√≥n
            if 15 <= temp <= 25 and 50 <= humedad <= 70:
                recomendaciones['fertilizacion'].append(f"{estacion}: Condiciones √≥ptimas para fertilizaci√≥n")
            
            # Recomendaciones de cosecha
            if temp < 10 or temp > 30:
                recomendaciones['cosecha'].append(f"{estacion}: Evitar cosecha (Condiciones adversas)")
        
        return recomendaciones

class SistemaPrediccionesML:
    """Sistema de predicciones con Machine Learning"""
    
    def __init__(self):
        self.modelos = {
            'temperatura': None,
            'humedad': None,
            'precipitacion': None
        }
    
    def predecir_tendencias(self, datos_historicos: List[Dict]) -> Dict:
        """Predice tendencias futuras basadas en datos hist√≥ricos"""
        predicciones = {
            'temperatura_24h': {'min': 12, 'max': 28, 'promedio': 20},
            'humedad_24h': {'min': 45, 'max': 85, 'promedio': 65},
            'precipitacion_24h': {'probabilidad': 0.3, 'mm': 2.5},
            'riesgo_helada': 0.15,
            'condiciones_cultivo': 'Favorables'
        }
        return predicciones

class SistemaAlertasVisuales:
    """Sistema de alertas visuales avanzado"""
    
    def __init__(self):
        self.niveles_alerta = {
            'verde': {'min': 0, 'max': 0.3},
            'amarillo': {'min': 0.3, 'max': 0.7},
            'rojo': {'min': 0.7, 'max': 1.0}
        }
    
    def calcular_nivel_alerta(self, riesgo: float) -> str:
        """Calcula el nivel de alerta basado en el riesgo"""
        for nivel, rango in self.niveles_alerta.items():
            if rango['min'] <= riesgo <= rango['max']:
                return nivel
        return 'verde'
    
    def generar_alertas(self, datos_estaciones: Dict) -> List[Dict]:
        """Genera alertas basadas en los datos"""
        alertas = []
        
        for estacion, datos in datos_estaciones.items():
            if not datos:
                continue
                
            temp = datos.get('temperatura_actual', 0)
            humedad = datos.get('humedad_relativa', 0)
            viento = datos.get('velocidad_viento', 0)
            
            # Alerta de helada
            if temp < 5:
                riesgo_helada = 0.9
                nivel = self.calcular_nivel_alerta(riesgo_helada)
                alertas.append({
                    'estacion': estacion,
                    'tipo': 'Helada',
                    'descripcion': f'Temperatura cr√≠tica: {temp}¬∞C',
                    'nivel': nivel,
                    'prioridad': 'Alta'
                })
            
            # Alerta de viento fuerte
            if viento > 25:
                riesgo_viento = 0.8
                nivel = self.calcular_nivel_alerta(riesgo_viento)
                alertas.append({
                    'estacion': estacion,
                    'tipo': 'Viento',
                    'descripcion': f'Viento fuerte: {viento} km/h',
                    'nivel': nivel,
                    'prioridad': 'Media'
                })
            
            # Alerta de humedad extrema
            if humedad < 30 or humedad > 90:
                riesgo_humedad = 0.7
                nivel = self.calcular_nivel_alerta(riesgo_humedad)
                alertas.append({
                    'estacion': estacion,
                    'tipo': 'Humedad',
                    'descripcion': f'Humedad extrema: {humedad}%',
                    'nivel': nivel,
                    'prioridad': 'Media'
                })
        
        return alertas

class ConectorAPIsMeteorologicas:
    """Conector para APIs meteorol√≥gicas"""
    
    def __init__(self):
        self.openmeteo_url = "https://api.open-meteo.com/v1/forecast"
    
    def obtener_datos_openmeteo_coordenadas(self, lat: float, lon: float) -> Optional[Dict]:
        """Obtiene datos de OpenMeteo para coordenadas espec√≠ficas"""
        try:
            params = {
                'latitude': lat,
                'longitude': lon,
                'current': 'temperature_2m,relative_humidity_2m,pressure_msl,wind_speed_10m,wind_direction_10m,precipitation',
                'hourly': 'temperature_2m,relative_humidity_2m,pressure_msl,wind_speed_10m,precipitation',
                'timezone': 'America/Santiago'
            }
            
            response = requests.get(self.openmeteo_url, params=params, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                current = data.get('current', {})
                
                return {
                    'temperatura_actual': current.get('temperature_2m', 0),
                    'humedad_relativa': current.get('relative_humidity_2m', 0),
                    'presion_atmosferica': current.get('pressure_msl', 0),
                    'velocidad_viento': current.get('wind_speed_10m', 0),
                    'direccion_viento': current.get('wind_direction_10m', 0),
                    'precipitacion': current.get('precipitation', 0),
                    'fecha_actualizacion': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                }
            else:
                return None
                
        except Exception as e:
            st.error(f"Error obteniendo datos de OpenMeteo: {e}")
            return None

class DashboardAgricolaAvanzadoCompleto:
    """Dashboard agr√≠cola avanzado con todas las funcionalidades"""
    
    def __init__(self):
        self.sistema_recomendaciones = SistemaRecomendacionesAgricolas()
        self.conector_apis = ConectorAPIsMeteorologicas()
        self.sistema_ml = SistemaPrediccionesML()
        self.sistema_alertas = SistemaAlertasVisuales()
        self._inicializar_session_state()
    
    def _inicializar_session_state(self):
        """Inicializar variables de sesi√≥n"""
        if 'datos_meteorologicos' not in st.session_state:
            st.session_state.datos_meteorologicos = None
        if 'datos_reales_apis' not in st.session_state:
            st.session_state.datos_reales_apis = None
        if 'ultima_actualizacion' not in st.session_state:
            st.session_state.ultima_actualizacion = None
        if 'analisis_heladas' not in st.session_state:
            st.session_state.analisis_heladas = self._generar_analisis_heladas()
    
    def _generar_analisis_heladas(self):
        """Genera an√°lisis de heladas detallado"""
        return {
            'riesgo_alto': 2,
            'riesgo_medio': 3,
            'riesgo_bajo': 1,
            'temperatura_minima': -2.5,
            'probabilidad_helada': 0.15,
            'estaciones_riesgo': ['Quillota_Norte', 'San_Isidro'],
            'recomendaciones': [
                'Activar sistemas de protecci√≥n',
                'Cubrir cultivos sensibles',
                'Monitorear cada 2 horas'
            ]
        }
    
    def _obtener_datos_reales_apis(self):
        """Obtener datos reales de las APIs meteorol√≥gicas con barra de progreso"""
        try:
            # Coordenadas de las 6 estaciones meteorol√≥gicas del Valle de Quillota
            estaciones = {
                "Quillota_Centro": {"lat": -32.8833, "lon": -71.2667},
                "La_Cruz": {"lat": -32.8167, "lon": -71.2167},
                "Nogales": {"lat": -32.7500, "lon": -71.2167},
                "San_Isidro": {"lat": -32.9167, "lon": -71.2333},
                "Pocochay": {"lat": -32.8500, "lon": -71.3000},
                "Valle_Hermoso": {"lat": -32.9333, "lon": -71.2833}
            }
            
            datos_reales = {}
            errores = []
            exitosos = 0
            
            # Crear barra de progreso
            progress_bar = st.progress(0)
            status_text = st.empty()
            
            total_estaciones = len(estaciones)
            
            for i, (nombre_estacion, coordenadas) in enumerate(estaciones.items()):
                try:
                    status_text.text(f"Descargando datos de {nombre_estacion}...")
                    
                    datos_estacion = self.conector_apis.obtener_datos_openmeteo_coordenadas(
                        coordenadas["lat"], 
                        coordenadas["lon"]
                    )
                    
                    if datos_estacion and isinstance(datos_estacion, dict):
                        datos_reales[nombre_estacion] = datos_estacion
                        exitosos += 1
                        st.success(f"‚úÖ {nombre_estacion}: Datos obtenidos correctamente")
                    else:
                        errores.append(f"{nombre_estacion}: Datos vac√≠os o inv√°lidos")
                        st.warning(f"‚ö†Ô∏è {nombre_estacion}: Datos vac√≠os o inv√°lidos")
                        
                except Exception as e:
                    error_msg = f"{nombre_estacion}: {str(e)}"
                    errores.append(error_msg)
                    st.error(f"‚ùå {nombre_estacion}: {str(e)}")
                
                # Actualizar barra de progreso
                progress = (i + 1) / total_estaciones
                progress_bar.progress(progress)
            
            # Limpiar elementos temporales
            progress_bar.empty()
            status_text.empty()
            
            if datos_reales:
                st.session_state.datos_reales_apis = datos_reales
                st.session_state.ultima_actualizacion = datetime.now()
                
                # Mostrar resumen
                st.success(f"üå°Ô∏è Descarga completada: {exitosos}/{total_estaciones} estaciones exitosas")
                
                if errores:
                    st.warning(f"‚ö†Ô∏è {len(errores)} errores detectados:")
                    for error in errores:
                        st.text(f"   - {error}")
                
                return datos_reales
            else:
                st.error("‚ùå No se pudieron obtener datos de ninguna estaci√≥n")
                if errores:
                    st.error("Errores detallados:")
                    for error in errores:
                        st.text(f"   - {error}")
                return None
                
        except Exception as e:
            st.error(f"‚ùå Error general obteniendo datos de APIs: {str(e)}")
            return None
    
    def _mostrar_resumen_datos_avanzado(self, datos_reales: Dict):
        """Mostrar resumen avanzado de los datos obtenidos"""
        if not datos_reales:
            st.warning("No hay datos para mostrar")
            return
        
        st.subheader("üìä Resumen Avanzado de Datos Meteorol√≥gicos")
        
        # Crear DataFrame con datos resumidos
        resumen_data = []
        
        for estacion, datos in datos_reales.items():
            if datos and isinstance(datos, dict):
                resumen_data.append({
                    "Estaci√≥n": estacion.replace("_", " "),
                    "Temperatura (¬∞C)": datos.get("temperatura_actual", "N/A"),
                    "Humedad (%)": datos.get("humedad_relativa", "N/A"),
                    "Presi√≥n (hPa)": datos.get("presion_atmosferica", "N/A"),
                    "Viento (km/h)": datos.get("velocidad_viento", "N/A"),
                    "Direcci√≥n Viento (¬∞)": datos.get("direccion_viento", "N/A"),
                    "Precipitaci√≥n (mm)": datos.get("precipitacion", "N/A"),
                    "√öltima Actualizaci√≥n": datos.get("fecha_actualizacion", "N/A")
                })
        
        if resumen_data:
            df_resumen = pd.DataFrame(resumen_data)
            
            # Mostrar tabla con estilo
            st.dataframe(df_resumen, use_container_width=True)
            
            # Mostrar estad√≠sticas generales con m√©tricas avanzadas
            col1, col2, col3, col4, col5 = st.columns(5)
            
            # Calcular estad√≠sticas
            temp_vals = [float(d.get('temperatura_actual', 0)) for d in resumen_data 
                        if d.get('temperatura_actual', 'N/A') != 'N/A' 
                        and str(d.get('temperatura_actual', 'N/A')).replace('.', '').replace('-', '').isdigit()]
            
            hum_vals = [float(d.get('Humedad (%)', 0)) for d in resumen_data 
                       if d.get('Humedad (%)', 'N/A') != 'N/A' 
                       and str(d.get('Humedad (%)', 'N/A')).replace('.', '').replace('-', '').isdigit()]
            
            pres_vals = [float(d.get('Presi√≥n (hPa)', 0)) for d in resumen_data 
                        if d.get('Presi√≥n (hPa)', 'N/A') != 'N/A' 
                        and str(d.get('Presi√≥n (hPa)', 'N/A')).replace('.', '').replace('-', '').isdigit()]
            
            viento_vals = [float(d.get('Viento (km/h)', 0)) for d in resumen_data 
                          if d.get('Viento (km/h)', 'N/A') != 'N/A' 
                          and str(d.get('Viento (km/h)', 'N/A')).replace('.', '').replace('-', '').isdigit()]
            
            with col1:
                temp_prom = np.mean(temp_vals) if temp_vals else 0
                temp_max = np.max(temp_vals) if temp_vals else 0
                temp_min = np.min(temp_vals) if temp_vals else 0
                st.metric("üå°Ô∏è Temp. Promedio", f"{temp_prom:.1f}¬∞C", delta=f"Rango: {temp_min:.1f}-{temp_max:.1f}¬∞C")
            
            with col2:
                hum_prom = np.mean(hum_vals) if hum_vals else 0
                st.metric("üíß Humedad Promedio", f"{hum_prom:.1f}%")
            
            with col3:
                pres_prom = np.mean(pres_vals) if pres_vals else 0
                st.metric("üåÄ Presi√≥n Promedio", f"{pres_prom:.1f} hPa")
            
            with col4:
                viento_prom = np.mean(viento_vals) if viento_vals else 0
                viento_max = np.max(viento_vals) if viento_vals else 0
                st.metric("üí® Viento Promedio", f"{viento_prom:.1f} km/h", delta=f"M√°x: {viento_max:.1f} km/h")
            
            with col5:
                # Estado general del sistema
                estado_general = "Favorable"
                if temp_prom < 5 or temp_prom > 35 or hum_prom < 30 or viento_prom > 25:
                    estado_general = "Atenci√≥n"
                if temp_prom < 0 or viento_prom > 40:
                    estado_general = "Cr√≠tico"
                
                st.metric("üéØ Estado General", estado_general)
    
    def _mostrar_graficos_avanzados(self, datos_reales: Dict):
        """Mostrar gr√°ficos avanzados con Plotly moderno"""
        if not datos_reales:
            return
        
        st.subheader("üìà An√°lisis Visual Avanzado")
        
        # Preparar datos para gr√°ficos
        estaciones = []
        temperaturas = []
        humedades = []
        presiones = []
        vientos = []
        
        for estacion, datos in datos_reales.items():
            if datos and isinstance(datos, dict):
                temp = datos.get("temperatura_actual", None)
                hum = datos.get("humedad_relativa", None)
                pres = datos.get("presion_atmosferica", None)
                viento = datos.get("velocidad_viento", None)
                
                if all(val is not None for val in [temp, hum, pres, viento]):
                    estaciones.append(estacion.replace("_", " "))
                    temperaturas.append(float(temp))
                    humedades.append(float(hum))
                    presiones.append(float(pres))
                    vientos.append(float(viento))
        
        if estaciones:
            # Gr√°fico combinado con subplots
            fig = make_subplots(
                rows=2, cols=2,
                subplot_titles=('Temperaturas por Estaci√≥n', 'Humedad Relativa', 
                              'Presi√≥n Atmosf√©rica', 'Velocidad del Viento'),
                specs=[[{"secondary_y": False}, {"secondary_y": False}],
                       [{"secondary_y": False}, {"secondary_y": False}]]
            )
            
            # Temperaturas
            fig.add_trace(
                go.Bar(x=estaciones, y=temperaturas, name='Temperatura (¬∞C)', 
                      marker_color='red', text=temperaturas, textposition='auto'),
                row=1, col=1
            )
            
            # Humedad
            fig.add_trace(
                go.Bar(x=estaciones, y=humedades, name='Humedad (%)', 
                      marker_color='blue', text=humedades, textposition='auto'),
                row=1, col=2
            )
            
            # Presi√≥n
            fig.add_trace(
                go.Bar(x=estaciones, y=presiones, name='Presi√≥n (hPa)', 
                      marker_color='green', text=presiones, textposition='auto'),
                row=2, col=1
            )
            
            # Viento
            fig.add_trace(
                go.Bar(x=estaciones, y=vientos, name='Viento (km/h)', 
                      marker_color='orange', text=vientos, textposition='auto'),
                row=2, col=2
            )
            
            fig.update_layout(
                title_text="Dashboard Meteorol√≥gico Multi-Variable",
                showlegend=False,
                height=600,
                template='plotly_white'
            )
            
            st.plotly_chart(fig, config=PLOTLY_CONFIG, use_container_width=True)
            
            # Gr√°fico de dispersi√≥n avanzado
            fig_scatter = go.Figure()
            
            fig_scatter.add_trace(go.Scatter(
                x=temperaturas,
                y=humedades,
                mode='markers+text',
                text=estaciones,
                textposition='top center',
                marker=dict(
                    size=[v*2 for v in vientos],  # Tama√±o basado en velocidad del viento
                    color=presiones,
                    colorscale='Viridis',
                    showscale=True,
                    colorbar=dict(title="Presi√≥n (hPa)"),
                    line=dict(width=2, color='black')
                ),
                name='Estaciones Meteorol√≥gicas'
            ))
            
            fig_scatter.update_layout(
                title='An√°lisis Multivariable: Temperatura vs Humedad',
                xaxis_title='Temperatura (¬∞C)',
                yaxis_title='Humedad Relativa (%)',
                height=500,
                template='plotly_white'
            )
            
            st.plotly_chart(fig_scatter, config=PLOTLY_CONFIG, use_container_width=True)
    
    def _mostrar_recomendaciones_avanzadas(self, datos_reales: Dict):
        """Mostrar recomendaciones agr√≠colas avanzadas"""
        if not datos_reales:
            st.warning("No hay datos suficientes para generar recomendaciones")
            return
        
        st.subheader("üå± Recomendaciones Agr√≠colas Avanzadas")
        
        # Generar recomendaciones
        recomendaciones = self.sistema_recomendaciones.generar_recomendaciones(datos_reales)
        
        # Mostrar recomendaciones por categor√≠a
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("üíß Riego y Humedad")
            if recomendaciones['riego']:
                for rec in recomendaciones['riego']:
                    st.info(f"üíß {rec}")
            else:
                st.success("‚úÖ Condiciones de riego adecuadas")
            
            st.subheader("‚ùÑÔ∏è Protecci√≥n contra Heladas")
            if recomendaciones['heladas']:
                for rec in recomendaciones['heladas']:
                    st.error(f"‚ùÑÔ∏è {rec}")
            else:
                st.success("‚úÖ Sin riesgo de heladas")
        
        with col2:
            st.subheader("üêõ Control de Plagas")
            if recomendaciones['plagas']:
                for rec in recomendaciones['plagas']:
                    st.warning(f"üêõ {rec}")
            else:
                st.success("‚úÖ Condiciones desfavorables para plagas")
            
            st.subheader("üåø Fertilizaci√≥n")
            if recomendaciones['fertilizacion']:
                for rec in recomendaciones['fertilizacion']:
                    st.success(f"üåø {rec}")
            else:
                st.info("‚ÑπÔ∏è Condiciones no √≥ptimas para fertilizaci√≥n")
        
        # Predicciones ML
        st.subheader("ü§ñ Predicciones con Machine Learning")
        predicciones = self.sistema_ml.predecir_tendencias([])
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.metric("üìä Temp. 24h", f"{predicciones['temperatura_24h']['promedio']:.1f}¬∞C", 
                     delta=f"Rango: {predicciones['temperatura_24h']['min']}-{predicciones['temperatura_24h']['max']}¬∞C")
        
        with col2:
            st.metric("üíß Humedad 24h", f"{predicciones['humedad_24h']['promedio']:.1f}%",
                     delta=f"Rango: {predicciones['humedad_24h']['min']}-{predicciones['humedad_24h']['max']}%")
        
        with col3:
            prob_lluvia = predicciones['precipitacion_24h']['probabilidad'] * 100
            st.metric("üåßÔ∏è Prob. Lluvia", f"{prob_lluvia:.0f}%",
                     delta=f"{predicciones['precipitacion_24h']['mm']:.1f} mm")
    
    def _mostrar_alertas_heladas_avanzadas(self):
        """Mostrar alertas de heladas avanzadas"""
        st.subheader("‚ùÑÔ∏è Sistema Avanzado de Alertas de Heladas")
        
        analisis = st.session_state.analisis_heladas
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.metric("üö® Riesgo Alto", analisis['riesgo_alto'], delta="Estaciones")
        
        with col2:
            st.metric("‚ö†Ô∏è Riesgo Medio", analisis['riesgo_medio'], delta="Estaciones")
        
        with col3:
            st.metric("‚úÖ Riesgo Bajo", analisis['riesgo_bajo'], delta="Estaciones")
        
        # Gr√°fico de riesgo de heladas
        riesgo_data = {
            'Riesgo Alto': analisis['riesgo_alto'],
            'Riesgo Medio': analisis['riesgo_medio'],
            'Riesgo Bajo': analisis['riesgo_bajo']
        }
        
        fig = go.Figure(data=[
            go.Pie(
                labels=list(riesgo_data.keys()),
                values=list(riesgo_data.values()),
                hole=0.4,
                marker_colors=['#FF6B6B', '#FFE66D', '#4ECDC4'],
                textinfo='label+percent+value',
                textfont_size=12
            )
        ])
        
        fig.update_layout(
            title="Distribuci√≥n del Riesgo de Heladas por Estaci√≥n",
            showlegend=True,
            height=400,
            template='plotly_white'
        )
        
        st.plotly_chart(fig, config=PLOTLY_CONFIG, use_container_width=True)
        
        # Mostrar recomendaciones espec√≠ficas
        st.subheader("üìã Recomendaciones Espec√≠ficas")
        for i, rec in enumerate(analisis['recomendaciones'], 1):
            st.info(f"{i}. {rec}")
        
        # Mostrar estaciones en riesgo
        if analisis['estaciones_riesgo']:
            st.subheader("‚ö†Ô∏è Estaciones en Riesgo")
            for estacion in analisis['estaciones_riesgo']:
                st.warning(f"üö® {estacion.replace('_', ' ')}")
    
    def _mostrar_alertas_visuales(self, datos_reales: Dict):
        """Mostrar sistema de alertas visuales"""
        if not datos_reales:
            return
        
        st.subheader("üö® Sistema de Alertas Visuales")
        
        alertas = self.sistema_alertas.generar_alertas(datos_reales)
        
        if alertas:
            for alerta in alertas:
                if alerta['nivel'] == 'rojo':
                    st.error(f"üî¥ **{alerta['tipo']}** en {alerta['estacion']}: {alerta['descripcion']}")
                elif alerta['nivel'] == 'amarillo':
                    st.warning(f"üü° **{alerta['tipo']}** en {alerta['estacion']}: {alerta['descripcion']}")
                else:
                    st.info(f"üü¢ **{alerta['tipo']}** en {alerta['estacion']}: {alerta['descripcion']}")
        else:
            st.success("‚úÖ No hay alertas activas en este momento")
    
    def ejecutar(self):
        """Ejecutar el dashboard principal"""
        # Header principal
        st.title("üå± METGO 3D - Dashboard Agr√≠cola Avanzado Completo")
        st.markdown("**Sistema Integral de Gesti√≥n Agr√≠cola Avanzado para el Valle de Quillota**")
        st.markdown("---")
        
        # Sidebar con controles
        with st.sidebar:
            st.header("üéõÔ∏è Controles del Sistema")
            
            # Estado actual
            st.subheader("üìä Estado Actual")
            if st.session_state.ultima_actualizacion:
                st.text(f"√öltima actualizaci√≥n: {st.session_state.ultima_actualizacion.strftime('%H:%M:%S')}")
            else:
                st.text("Estado: Sin datos")
            
            st.markdown("---")
            
            # Bot√≥n para descargar datos
            if st.button("üîÑ Descargar Datos Reales", use_container_width=True):
                with st.spinner("Descargando datos meteorol√≥gicos..."):
                    self._obtener_datos_reales_apis()
            
            # Bot√≥n para limpiar datos
            if st.button("üóëÔ∏è Limpiar Datos", use_container_width=True):
                st.session_state.datos_reales_apis = None
                st.session_state.ultima_actualizacion = None
                st.rerun()
            
            st.markdown("---")
            
            # Informaci√≥n del sistema
            st.subheader("‚ÑπÔ∏è Informaci√≥n del Sistema")
            st.info("""
            **Caracter√≠sticas Avanzadas:**
            - üìä An√°lisis multivariable
            - ü§ñ Predicciones con ML
            - üö® Sistema de alertas
            - üå± Recomendaciones inteligentes
            - üìà Visualizaciones interactivas
            - ‚ùÑÔ∏è Monitoreo de heladas
            
            **Estaciones Monitoreadas:**
            - Quillota Centro
            - La Cruz
            - Nogales
            - San Isidro
            - Pocochay
            - Valle Hermoso
            
            **Fuente de Datos:**
            OpenMeteo API (Gratuita)
            """)
        
        # Contenido principal
        if st.session_state.datos_reales_apis:
            # Mostrar resumen de datos
            self._mostrar_resumen_datos_avanzado(st.session_state.datos_reales_apis)
            
            st.markdown("---")
            
            # Mostrar alertas visuales
            self._mostrar_alertas_visuales(st.session_state.datos_reales_apis)
            
            st.markdown("---")
            
            # Mostrar gr√°ficos avanzados
            self._mostrar_graficos_avanzados(st.session_state.datos_reales_apis)
            
            st.markdown("---")
            
            # Mostrar recomendaciones avanzadas
            self._mostrar_recomendaciones_avanzadas(st.session_state.datos_reales_apis)
            
            st.markdown("---")
            
            # Mostrar alertas de heladas
            self._mostrar_alertas_heladas_avanzadas()
            
        else:
            # Mostrar mensaje de bienvenida
            st.info("üëÜ Use el bot√≥n 'Descargar Datos Reales' en la barra lateral para comenzar")
            
            # Mostrar informaci√≥n sobre el sistema
            st.subheader("üå± Sistema de Gesti√≥n Agr√≠cola METGO 3D Avanzado")
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.markdown("""
                **Funcionalidades Avanzadas:**
                - üìä Monitoreo meteorol√≥gico en tiempo real
                - ü§ñ Predicciones con Machine Learning
                - üö® Sistema de alertas visuales inteligente
                - üå°Ô∏è An√°lisis multivariable de temperaturas
                - üíß Control avanzado de humedad y riego
                - üí® Monitoreo de vientos y presi√≥n
                - üå± Recomendaciones agr√≠colas automatizadas
                - üìà Visualizaciones interactivas avanzadas
                - ‚ùÑÔ∏è Sistema especializado de alertas de heladas
                """)
            
            with col2:
                st.markdown("""
                **Beneficios del Sistema:**
                - ‚è∞ Datos actualizados en tiempo real
                - üéØ Recomendaciones personalizadas por estaci√≥n
                - üì± Interfaz intuitiva y profesional
                - üîÑ Actualizaci√≥n autom√°tica de datos
                - üìä An√°lisis estad√≠sticos avanzados
                - üåç Cobertura completa del Valle de Quillota
                - üö® Alertas preventivas tempranas
                - ü§ñ Predicciones basadas en IA
                - üìà Reportes detallados y visuales
                """)

def main():
    """Funci√≥n principal"""
    dashboard = DashboardAgricolaAvanzadoCompleto()
    dashboard.ejecutar()

if __name__ == "__main__":
    main()
