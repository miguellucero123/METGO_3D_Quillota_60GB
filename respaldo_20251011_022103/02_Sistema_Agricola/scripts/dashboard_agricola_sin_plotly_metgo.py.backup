"""
DASHBOARD AGRÃCOLA SIN PLOTLY - METGO 3D QUILLOTA
VersiÃ³n que usa solo Streamlit nativo para evitar warnings de Plotly
"""

import streamlit as st
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import json
import os
from conector_apis_meteorologicas_reales import ConectorAPIsMeteorologicas

# ConfiguraciÃ³n de la pÃ¡gina
st.set_page_config(
    page_title="METGO 3D - Dashboard AgrÃ­cola Sin Plotly",
    page_icon="ğŸŒ±",
    layout="wide",
    initial_sidebar_state="expanded"
)

class DashboardAgricolaSinPlotly:
    def __init__(self):
        self.conector_apis = ConectorAPIsMeteorologicas()
        self._inicializar_session_state()
    
    def _inicializar_session_state(self):
        """Inicializar variables de sesiÃ³n"""
        if 'datos_meteorologicos' not in st.session_state:
            st.session_state.datos_meteorologicos = None
        if 'datos_reales_apis' not in st.session_state:
            st.session_state.datos_reales_apis = None
        if 'ultima_actualizacion' not in st.session_state:
            st.session_state.ultima_actualizacion = None
        if 'estado_descarga' not in st.session_state:
            st.session_state.estado_descarga = "Pendiente"
    
    def _obtener_datos_reales_apis(self):
        """Obtener datos reales de las APIs meteorolÃ³gicas"""
        try:
            st.session_state.estado_descarga = "Descargando..."
            
            # Coordenadas de las 6 estaciones meteorolÃ³gicas del Valle de Quillota
            estaciones = {
                "Quillota_Centro": {"lat": -32.8833, "lon": -71.2667},
                "La_Cruz": {"lat": -32.8167, "lon": -71.2167},
                "Nogales": {"lat": -32.7500, "lon": -71.2167},
                "San_Isidro": {"lat": -32.9167, "lon": -71.2333},
                "Pocochay": {"lat": -32.8500, "lon": -71.3000},
                "Valle_Hermoso": {"lat": -32.9333, "lon": -71.2833}
            }
            
            datos_reales = {}
            errores = []
            exitosos = 0
            
            # Crear barra de progreso
            progress_bar = st.progress(0)
            status_text = st.empty()
            
            total_estaciones = len(estaciones)
            
            for i, (nombre_estacion, coordenadas) in enumerate(estaciones.items()):
                try:
                    status_text.text(f"Descargando datos de {nombre_estacion}...")
                    
                    # Obtener datos de OpenMeteo
                    datos_estacion = self.conector_apis.obtener_datos_openmeteo_coordenadas(
                        coordenadas["lat"], 
                        coordenadas["lon"]
                    )
                    
                    if datos_estacion and isinstance(datos_estacion, dict):
                        datos_reales[nombre_estacion] = datos_estacion
                        exitosos += 1
                        st.success(f"âœ… {nombre_estacion}: Datos obtenidos correctamente")
                    else:
                        errores.append(f"{nombre_estacion}: Datos vacÃ­os o invÃ¡lidos")
                        st.warning(f"âš ï¸ {nombre_estacion}: Datos vacÃ­os o invÃ¡lidos")
                        
                except Exception as e:
                    error_msg = f"{nombre_estacion}: {str(e)}"
                    errores.append(error_msg)
                    st.error(f"âŒ {nombre_estacion}: {str(e)}")
                
                # Actualizar barra de progreso
                progress = (i + 1) / total_estaciones
                progress_bar.progress(progress)
            
            # Limpiar elementos temporales
            progress_bar.empty()
            status_text.empty()
            
            if datos_reales:
                st.session_state.datos_reales_apis = datos_reales
                st.session_state.ultima_actualizacion = datetime.now()
                st.session_state.estado_descarga = "Completado"
                
                # Mostrar resumen
                st.success(f"ğŸŒ¡ï¸ Descarga completada: {exitosos}/{total_estaciones} estaciones exitosas")
                
                if errores:
                    st.warning(f"âš ï¸ {len(errores)} errores detectados:")
                    for error in errores:
                        st.text(f"   - {error}")
                
                return datos_reales
            else:
                st.session_state.estado_descarga = "Error"
                st.error("âŒ No se pudieron obtener datos de ninguna estaciÃ³n")
                if errores:
                    st.error("Errores detallados:")
                    for error in errores:
                        st.text(f"   - {error}")
                return None
                
        except Exception as e:
            st.session_state.estado_descarga = "Error"
            st.error(f"âŒ Error general obteniendo datos de APIs: {str(e)}")
            return None
    
    def _mostrar_resumen_datos(self, datos_reales):
        """Mostrar resumen de los datos obtenidos"""
        if not datos_reales:
            st.warning("No hay datos para mostrar")
            return
        
        st.subheader("ğŸ“Š Resumen de Datos MeteorolÃ³gicos")
        
        # Crear DataFrame con datos resumidos
        resumen_data = []
        
        for estacion, datos in datos_reales.items():
            if datos and isinstance(datos, dict):
                resumen_data.append({
                    "EstaciÃ³n": estacion.replace("_", " "),
                    "Temperatura (Â°C)": datos.get("temperatura_actual", "N/A"),
                    "Humedad (%)": datos.get("humedad_relativa", "N/A"),
                    "PresiÃ³n (hPa)": datos.get("presion_atmosferica", "N/A"),
                    "Viento (km/h)": datos.get("velocidad_viento", "N/A"),
                    "PrecipitaciÃ³n (mm)": datos.get("precipitacion", "N/A"),
                    "Ãšltima ActualizaciÃ³n": datos.get("fecha_actualizacion", "N/A")
                })
        
        if resumen_data:
            df_resumen = pd.DataFrame(resumen_data)
            st.dataframe(df_resumen, width='stretch')
            
            # Mostrar estadÃ­sticas generales usando mÃ©tricas de Streamlit
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                temp_vals = [float(d.get('temperatura_actual', 0)) for d in resumen_data 
                           if d.get('temperatura_actual', 'N/A') != 'N/A' and str(d.get('temperatura_actual', 'N/A')).replace('.', '').replace('-', '').isdigit()]
                st.metric("ğŸŒ¡ï¸ Temp. Promedio", f"{np.mean(temp_vals):.1f}Â°C" if temp_vals else "N/A")
            
            with col2:
                hum_vals = [float(d.get('Humedad (%)', 0)) for d in resumen_data 
                           if d.get('Humedad (%)', 'N/A') != 'N/A' and str(d.get('Humedad (%)', 'N/A')).replace('.', '').replace('-', '').isdigit()]
                st.metric("ğŸ’§ Humedad Promedio", f"{np.mean(hum_vals):.1f}%" if hum_vals else "N/A")
            
            with col3:
                pres_vals = [float(d.get('PresiÃ³n (hPa)', 0)) for d in resumen_data 
                            if d.get('PresiÃ³n (hPa)', 'N/A') != 'N/A' and str(d.get('PresiÃ³n (hPa)', 'N/A')).replace('.', '').replace('-', '').isdigit()]
                st.metric("ğŸŒ€ PresiÃ³n Promedio", f"{np.mean(pres_vals):.1f} hPa" if pres_vals else "N/A")
            
            with col4:
                viento_vals = [float(d.get('Viento (km/h)', 0)) for d in resumen_data 
                              if d.get('Viento (km/h)', 'N/A') != 'N/A' and str(d.get('Viento (km/h)', 'N/A')).replace('.', '').replace('-', '').isdigit()]
                st.metric("ğŸ’¨ Viento Promedio", f"{np.mean(viento_vals):.1f} km/h" if viento_vals else "N/A")
    
    def _mostrar_visualizaciones_streamlit(self, datos_reales):
        """Mostrar visualizaciones usando solo Streamlit nativo"""
        if not datos_reales:
            return
        
        st.subheader("ğŸŒ¡ï¸ AnÃ¡lisis de Temperaturas por EstaciÃ³n")
        
        # Preparar datos para visualizaciones
        estaciones = []
        temperaturas = []
        humedades = []
        
        for estacion, datos in datos_reales.items():
            if datos and isinstance(datos, dict):
                temp = datos.get("temperatura_actual", None)
                hum = datos.get("humedad_relativa", None)
                
                if temp is not None and hum is not None:
                    estaciones.append(estacion.replace("_", " "))
                    temperaturas.append(float(temp))
                    humedades.append(float(hum))
        
        if estaciones:
            # Mostrar datos en formato de tabla con colores
            st.subheader("ğŸ“Š Tabla de Temperaturas por EstaciÃ³n")
            
            # Crear DataFrame para mostrar
            df_visualizacion = pd.DataFrame({
                'EstaciÃ³n': estaciones,
                'Temperatura (Â°C)': temperaturas,
                'Humedad (%)': humedades
            })
            
            # Aplicar formato condicional
            def highlight_temp(val):
                if val == df_visualizacion['Temperatura (Â°C)'].max():
                    return 'background-color: red; color: white'
                elif val == df_visualizacion['Temperatura (Â°C)'].min():
                    return 'background-color: blue; color: white'
                else:
                    return ''
            
            def highlight_hum(val):
                if val > 80:
                    return 'background-color: lightgreen'
                elif val < 40:
                    return 'background-color: lightcoral'
                else:
                    return ''
            
            styled_df = df_visualizacion.style.map(highlight_temp, subset=['Temperatura (Â°C)']).map(highlight_hum, subset=['Humedad (%)'])
            st.dataframe(styled_df, width='stretch')
            
            # Mostrar estadÃ­sticas
            col1, col2, col3 = st.columns(3)
            
            with col1:
                st.metric("ğŸŒ¡ï¸ Temp. MÃ¡xima", f"{max(temperaturas):.1f}Â°C")
            
            with col2:
                st.metric("ğŸŒ¡ï¸ Temp. MÃ­nima", f"{min(temperaturas):.1f}Â°C")
            
            with col3:
                st.metric("ğŸŒ¡ï¸ Temp. Promedio", f"{np.mean(temperaturas):.1f}Â°C")
            
            # Mostrar anÃ¡lisis de humedad
            st.subheader("ğŸ’§ AnÃ¡lisis de Humedad por EstaciÃ³n")
            
            col1, col2, col3 = st.columns(3)
            
            with col1:
                st.metric("ğŸ’§ Humedad MÃ¡xima", f"{max(humedades):.1f}%")
            
            with col2:
                st.metric("ğŸ’§ Humedad MÃ­nima", f"{min(humedades):.1f}%")
            
            with col3:
                st.metric("ğŸ’§ Humedad Promedio", f"{np.mean(humedades):.1f}%")
            
            # Mostrar relaciÃ³n temperatura vs humedad
            st.subheader("ğŸ“ˆ RelaciÃ³n Temperatura vs Humedad")
            
            # Crear tabla de correlaciÃ³n
            correlacion = np.corrcoef(temperaturas, humedades)[0, 1]
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.metric("ğŸ“Š CorrelaciÃ³n T-H", f"{correlacion:.3f}")
                
                if correlacion > 0.5:
                    st.success("âœ… CorrelaciÃ³n positiva fuerte")
                elif correlacion > 0.2:
                    st.info("â„¹ï¸ CorrelaciÃ³n positiva moderada")
                elif correlacion > -0.2:
                    st.warning("âš ï¸ CorrelaciÃ³n dÃ©bil")
                else:
                    st.error("âŒ CorrelaciÃ³n negativa")
            
            with col2:
                # Mostrar tendencia general
                if np.mean(temperaturas) > 15:
                    st.success("ğŸŒ¡ï¸ Temperaturas cÃ¡lidas")
                elif np.mean(temperaturas) < 10:
                    st.info("â„ï¸ Temperaturas frÃ­as")
                else:
                    st.info("ğŸŒ¤ï¸ Temperaturas moderadas")
                
                if np.mean(humedades) > 70:
                    st.success("ğŸ’§ Alta humedad")
                elif np.mean(humedades) < 50:
                    st.warning("ğŸœï¸ Baja humedad")
                else:
                    st.info("ğŸ’§ Humedad moderada")
    
    def _mostrar_recomendaciones_agricolas(self, datos_reales):
        """Mostrar recomendaciones agrÃ­colas basadas en los datos meteorolÃ³gicos"""
        if not datos_reales:
            st.warning("No hay datos suficientes para generar recomendaciones")
            return
        
        st.subheader("ğŸŒ± Recomendaciones AgrÃ­colas")
        
        # Calcular promedios regionales
        temp_valores = [float(d.get('temperatura_actual', 0)) for d in datos_reales.values() 
                       if d and isinstance(d, dict) and d.get('temperatura_actual', 'N/A') != 'N/A' and str(d.get('temperatura_actual', 'N/A')).replace('.', '').replace('-', '').isdigit()]
        hum_valores = [float(d.get('humedad_relativa', 0)) for d in datos_reales.values() 
                      if d and isinstance(d, dict) and d.get('humedad_relativa', 'N/A') != 'N/A' and str(d.get('humedad_relativa', 'N/A')).replace('.', '').replace('-', '').isdigit()]
        viento_valores = [float(d.get('velocidad_viento', 0)) for d in datos_reales.values() 
                         if d and isinstance(d, dict) and d.get('velocidad_viento', 'N/A') != 'N/A' and str(d.get('velocidad_viento', 'N/A')).replace('.', '').replace('-', '').isdigit()]
        
        temp_promedio = np.mean(temp_valores) if temp_valores else 0
        hum_promedio = np.mean(hum_valores) if hum_valores else 0
        viento_promedio = np.mean(viento_valores) if viento_valores else 0
        
        # Generar recomendaciones
        recomendaciones = []
        
        # Recomendaciones de riego
        if hum_promedio < 40:
            recomendaciones.append("ğŸš¿ **Riego**: Humedad baja detectada. Incrementar frecuencia de riego.")
        elif hum_promedio > 80:
            recomendaciones.append("â›” **Riego**: Humedad alta. Reducir riego para evitar enfermedades.")
        else:
            recomendaciones.append("âœ… **Riego**: Condiciones de humedad adecuadas.")
        
        # Recomendaciones de temperatura
        if temp_promedio < 5:
            recomendaciones.append("â„ï¸ **Heladas**: Temperatura baja. Activar sistema de protecciÃ³n contra heladas.")
        elif temp_promedio > 35:
            recomendaciones.append("â˜€ï¸ **Calor**: Temperatura alta. Incrementar riego y sombreado.")
        else:
            recomendaciones.append("ğŸŒ¡ï¸ **Temperatura**: Condiciones tÃ©rmicas favorables.")
        
        # Recomendaciones de viento
        if viento_promedio > 20:
            recomendaciones.append("ğŸ’¨ **Viento**: Vientos fuertes. Revisar estructuras y evitar aplicaciones.")
        else:
            recomendaciones.append("ğŸŒ¬ï¸ **Viento**: Condiciones de viento favorables.")
        
        # Mostrar recomendaciones
        for i, rec in enumerate(recomendaciones, 1):
            st.info(f"{i}. {rec}")
        
        # Mostrar mÃ©tricas actuales
        st.subheader("ğŸ“Š Condiciones Actuales del Valle")
        
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("ğŸŒ¡ï¸ Temperatura", f"{temp_promedio:.1f}Â°C")
        
        with col2:
            st.metric("ğŸ’§ Humedad", f"{hum_promedio:.1f}%")
        
        with col3:
            st.metric("ğŸ’¨ Viento", f"{viento_promedio:.1f} km/h")
        
        with col4:
            estado_general = "Favorable"
            if temp_promedio < 5 or temp_promedio > 35 or hum_promedio < 30 or viento_promedio > 25:
                estado_general = "AtenciÃ³n"
            st.metric("ğŸ¯ Estado", estado_general)
    
    def ejecutar(self):
        """Ejecutar el dashboard principal"""
        # Header principal
        st.title("ğŸŒ± METGO 3D - Dashboard AgrÃ­cola Sin Plotly")
        st.markdown("**Sistema Integral de GestiÃ³n AgrÃ­cola para el Valle de Quillota - Solo Streamlit Nativo**")
        st.markdown("---")
        
        # Sidebar con controles
        with st.sidebar:
            st.header("ğŸ›ï¸ Controles del Sistema")
            
            # Estado actual
            st.subheader("ğŸ“Š Estado Actual")
            st.text(f"Estado: {st.session_state.estado_descarga}")
            if st.session_state.ultima_actualizacion:
                st.text(f"Ãšltima actualizaciÃ³n: {st.session_state.ultima_actualizacion.strftime('%H:%M:%S')}")
            
            st.markdown("---")
            
            # BotÃ³n para descargar datos
            if st.button("ğŸ”„ Descargar Datos Reales", use_container_width=True):
                with st.spinner("Descargando datos meteorolÃ³gicos..."):
                    self._obtener_datos_reales_apis()
            
            # BotÃ³n para limpiar datos
            if st.button("ğŸ—‘ï¸ Limpiar Datos", use_container_width=True):
                st.session_state.datos_reales_apis = None
                st.session_state.estado_descarga = "Pendiente"
                st.rerun()
            
            st.markdown("---")
            
            # InformaciÃ³n del sistema
            st.subheader("â„¹ï¸ InformaciÃ³n")
            st.info("""
            **Estaciones Monitoreadas:**
            - Quillota Centro
            - La Cruz
            - Nogales
            - San Isidro
            - Pocochay
            - Valle Hermoso
            
            **Fuente de Datos:**
            OpenMeteo API (Gratuita)
            
            **Visualizaciones:**
            Solo Streamlit Nativo
            Sin Plotly
            """)
        
        # Contenido principal
        if st.session_state.datos_reales_apis:
            # Mostrar resumen de datos
            self._mostrar_resumen_datos(st.session_state.datos_reales_apis)
            
            st.markdown("---")
            
            # Mostrar visualizaciones
            self._mostrar_visualizaciones_streamlit(st.session_state.datos_reales_apis)
            
            st.markdown("---")
            
            # Mostrar recomendaciones
            self._mostrar_recomendaciones_agricolas(st.session_state.datos_reales_apis)
            
        else:
            # Mostrar mensaje de bienvenida
            st.info("ğŸ‘† Use el botÃ³n 'Descargar Datos Reales' en la barra lateral para comenzar")
            
            # Mostrar informaciÃ³n sobre el sistema
            st.subheader("ğŸŒ± Sistema de GestiÃ³n AgrÃ­cola METGO 3D - Sin Plotly")
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.markdown("""
                **Funcionalidades Principales:**
                - ğŸ“Š Monitoreo meteorolÃ³gico en tiempo real
                - ğŸŒ¡ï¸ AnÃ¡lisis de temperaturas por estaciÃ³n
                - ğŸ’§ Control de humedad y riego
                - ğŸ’¨ Monitoreo de vientos
                - ğŸŒ± Recomendaciones agrÃ­colas automÃ¡ticas
                - ğŸ“ˆ Visualizaciones con Streamlit nativo
                """)
            
            with col2:
                st.markdown("""
                **Beneficios:**
                - â° Datos actualizados cada hora
                - ğŸ¯ Recomendaciones personalizadas
                - ğŸ“± Interfaz intuitiva y fÃ¡cil de usar
                - ğŸ”„ ActualizaciÃ³n automÃ¡tica de datos
                - ğŸ“Š Reportes detallados por estaciÃ³n
                - ğŸŒ Cobertura completa del Valle de Quillota
                - âœ… Sin warnings de Plotly
                - ğŸš€ Visualizaciones nativas de Streamlit
                """)

def main():
    dashboard = DashboardAgricolaSinPlotly()
    dashboard.ejecutar()

if __name__ == "__main__":
    main()
