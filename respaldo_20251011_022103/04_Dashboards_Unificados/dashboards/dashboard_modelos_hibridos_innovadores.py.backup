"""
DASHBOARD MODELOS H√çBRIDOS INNOVADORES - METGO 3D QUILLOTA
Dashboard interactivo para crear y gestionar modelos h√≠bridos de m√°xima precisi√≥n
"""

import streamlit as st
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
import numpy as np
from datetime import datetime, timedelta
import json
from sistema_modelos_hibridos_innovadores import SistemaModelosHibridosInnovadores

# Configuraci√≥n de p√°gina
st.set_page_config(
    page_title="Modelos H√≠bridos Innovadores - METGO 3D",
    page_icon="üöÄ",
    layout="wide",
    initial_sidebar_state="expanded"
)

class DashboardModelosHibridosInnovadores:
    def __init__(self):
        self.sistema = SistemaModelosHibridosInnovadores()
        self._inicializar_session_state()
    
    def _inicializar_session_state(self):
        """Inicializar estado de sesi√≥n"""
        if 'modelos_hibridos_creados' not in st.session_state:
            st.session_state.modelos_hibridos_creados = []
        
        if 'proyecciones_hibridas_generadas' not in st.session_state:
            st.session_state.proyecciones_hibridas_generadas = {}
        
        if 'benchmark_realizado' not in st.session_state:
            st.session_state.benchmark_realizado = False
    
    def mostrar_header(self):
        """Mostrar header del dashboard"""
        st.title("üöÄ Sistema de Modelos H√≠bridos Innovadores")
        st.markdown("**Modelos de Machine Learning de m√°xima exactitud y rapidez para agricultura de precisi√≥n**")
        
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric(
                "Modelos H√≠bridos",
                len(self.sistema.modelos_hibridos),
                delta=None
            )
        
        with col2:
            st.metric(
                "Algoritmos Base",
                len(self.sistema.modelos_base_optimizados),
                delta=None
            )
        
        with col3:
            st.metric(
                "Tipos de H√≠bridos",
                4,
                delta=None
            )
        
        with col4:
            st.metric(
                "Proyecciones Hoy",
                len(st.session_state.proyecciones_hibridas_generadas),
                delta=None
            )
    
    def mostrar_sidebar(self):
        """Mostrar sidebar con controles"""
        st.sidebar.title("üéõÔ∏è Panel de Control Avanzado")
        
        # Secci√≥n de informaci√≥n del sistema
        st.sidebar.header("‚ÑπÔ∏è Sistema H√≠brido")
        st.sidebar.info("""
        **Caracter√≠sticas Innovadoras:**
        - üß† 5 algoritmos base optimizados
        - üîÑ 4 tipos de h√≠bridos disponibles
        - üìä An√°lisis de incertidumbre
        - ‚ö° Optimizaci√≥n autom√°tica de pesos
        - üéØ M√°xima precisi√≥n y rapidez
        """)
        
        # Mostrar modelos h√≠bridos activos
        modelos_hibridos = self.sistema.listar_modelos_hibridos()
        if modelos_hibridos:
            st.sidebar.header("ü§ñ Modelos H√≠bridos Activos")
            for modelo in modelos_hibridos:
                st.sidebar.write(f"**{modelo['nombre']}**")
                st.sidebar.write(f"‚Ä¢ Tipo: {modelo['tipo_hibrido']}")
                st.sidebar.write(f"‚Ä¢ R¬≤: {modelo['r2']:.6f}")
                st.sidebar.write(f"‚Ä¢ Tiempo: {modelo['tiempo_entrenamiento']:.2f}s")
                st.sidebar.write("---")
        else:
            st.sidebar.warning("No hay modelos h√≠bridos activos")
        
        # Secci√≥n de configuraci√≥n
        st.sidebar.header("‚öôÔ∏è Configuraci√≥n")
        
        mostrar_detalles_tecnicos = st.sidebar.checkbox("Mostrar Detalles T√©cnicos", value=False)
        incluir_incertidumbre = st.sidebar.checkbox("Incluir An√°lisis de Incertidumbre", value=True)
        
        return {
            'mostrar_detalles_tecnicos': mostrar_detalles_tecnicos,
            'incluir_incertidumbre': incluir_incertidumbre
        }
    
    def mostrar_tab_crear_hibrido(self):
        """Mostrar tab para crear modelos h√≠bridos innovadores"""
        st.header("üöÄ Crear Modelo H√≠brido Innovador")
        
        col1, col2 = st.columns([2, 1])
        
        with col1:
            # Formulario para crear modelo h√≠brido
            with st.form("crear_hibrido_form"):
                st.subheader("Configuraci√≥n del Modelo H√≠brido")
                
                # Informaci√≥n b√°sica
                col_nombre, col_tipo = st.columns(2)
                
                with col_nombre:
                    nombre_modelo = st.text_input(
                        "Nombre del Modelo H√≠brido",
                        placeholder="ej: Ensemble_Ultra_Temp",
                        help="Nombre √∫nico para identificar el modelo h√≠brido"
                    )
                
                with col_tipo:
                    tipos_hibridos = [
                        'ensemble_optimizado',
                        'stacking_avanzado', 
                        'voting_inteligente',
                        'hibrido_adaptativo'
                    ]
                    tipo_hibrido = st.selectbox(
                        "Tipo de H√≠brido",
                        tipos_hibridos,
                        format_func=lambda x: {
                            'ensemble_optimizado': 'üéØ Ensemble Optimizado',
                            'stacking_avanzado': 'üìö Stacking Avanzado',
                            'voting_inteligente': 'üó≥Ô∏è Voting Inteligente',
                            'hibrido_adaptativo': 'üîÑ H√≠brido Adaptativo'
                        }[x],
                        help="Tipo de modelo h√≠brido a crear"
                    )
                
                # Variable objetivo
                variables_objetivo = [
                    'temperatura_promedio',
                    'temperatura_max',
                    'temperatura_min',
                    'humedad_relativa',
                    'precipitacion',
                    'velocidad_viento',
                    'presion_atmosferica',
                    'radiacion_solar'
                ]
                
                variable_objetivo = st.selectbox(
                    "Variable Objetivo",
                    variables_objetivo,
                    format_func=lambda x: {
                        'temperatura_promedio': 'üå°Ô∏è Temperatura Promedio (¬∞C)',
                        'temperatura_max': 'üî• Temperatura M√°xima (¬∞C)',
                        'temperatura_min': '‚ùÑÔ∏è Temperatura M√≠nima (¬∞C)',
                        'humedad_relativa': 'üíß Humedad Relativa (%)',
                        'precipitacion': 'üåßÔ∏è Precipitaci√≥n (mm)',
                        'velocidad_viento': 'üí® Velocidad del Viento (km/h)',
                        'presion_atmosferica': 'üìä Presi√≥n Atmosf√©rica (hPa)',
                        'radiacion_solar': '‚òÄÔ∏è Radiaci√≥n Solar (W/m¬≤)'
                    }[x],
                    help="Variable que el modelo h√≠brido va a predecir"
                )
                
                # Descripci√≥n
                descripcion = st.text_area(
                    "Descripci√≥n del Modelo H√≠brido",
                    placeholder="Descripci√≥n del prop√≥sito y caracter√≠sticas del modelo h√≠brido...",
                    help="Descripci√≥n detallada del modelo h√≠brido"
                )
                
                # Informaci√≥n del tipo de h√≠brido seleccionado
                st.subheader("‚ÑπÔ∏è Informaci√≥n del Tipo de H√≠brido")
                
                info_hibridos = {
                    'ensemble_optimizado': {
                        'descripcion': 'Combina 5 algoritmos optimizados con pesos autom√°ticamente ajustados para m√°xima precisi√≥n.',
                        'ventajas': ['M√°xima precisi√≥n', 'Robusto a outliers', 'Optimizaci√≥n autom√°tica de pesos'],
                        'algoritmos': ['RandomForest Ultra', 'GradientBoosting Ultra', 'ExtraTrees Ultra', 'SVR Ultra', 'MLP Ultra']
                    },
                    'stacking_avanzado': {
                        'descripcion': 'Usa meta-aprendizaje con Ridge optimizado para combinar predicciones de modelos base.',
                        'ventajas': ['Meta-aprendizaje inteligente', 'Captura relaciones complejas', 'Validaci√≥n cruzada temporal'],
                        'algoritmos': ['5 modelos base + Meta-aprendizaje Ridge']
                    },
                    'voting_inteligente': {
                        'descripcion': 'Voting regressor con pesos adaptativos que se ajustan seg√∫n el rendimiento.',
                        'ventajas': ['Pesos adaptativos', 'R√°pido entrenamiento', 'Buen balance precisi√≥n/velocidad'],
                        'algoritmos': ['Todos los modelos base con voting inteligente']
                    },
                    'hibrido_adaptativo': {
                        'descripcion': 'Selecciona autom√°ticamente el mejor modelo individual seg√∫n el contexto.',
                        'ventajas': ['Selecci√≥n autom√°tica', 'M√°xima velocidad', 'Adaptaci√≥n contextual'],
                        'algoritmos': ['Mejor modelo individual seleccionado autom√°ticamente']
                    }
                }
                
                info = info_hibridos[tipo_hibrido]
                
                st.write(f"**Descripci√≥n:** {info['descripcion']}")
                
                with st.expander("Ver Ventajas"):
                    for ventaja in info['ventajas']:
                        st.write(f"‚Ä¢ {ventaja}")
                
                with st.expander("Ver Algoritmos"):
                    for algoritmo in info['algoritmos']:
                        st.write(f"‚Ä¢ {algoritmo}")
                
                # Bot√≥n de creaci√≥n
                submitted = st.form_submit_button("Crear Modelo H√≠brido Innovador", type="primary")
                
                if submitted:
                    if nombre_modelo and tipo_hibrido and variable_objetivo:
                        with st.spinner("Creando modelo h√≠brido innovador..."):
                            resultado = self.sistema.crear_modelo_hibrido_innovador(
                                nombre_modelo=nombre_modelo,
                                variable_objetivo=variable_objetivo,
                                tipo_hibrido=tipo_hibrido,
                                descripcion=descripcion
                            )
                            
                            if 'error' not in resultado:
                                st.success(f"Modelo h√≠brido '{nombre_modelo}' creado exitosamente!")
                                
                                # Mostrar m√©tricas avanzadas
                                metricas = resultado['metricas']
                                
                                col_metric1, col_metric2, col_metric3, col_metric4 = st.columns(4)
                                
                                with col_metric1:
                                    st.metric("R¬≤", f"{metricas['r2']:.6f}")
                                
                                with col_metric2:
                                    st.metric("RMSE", f"{metricas['rmse']:.6f}")
                                
                                with col_metric3:
                                    st.metric("MAE", f"{metricas['mae']:.6f}")
                                
                                with col_metric4:
                                    st.metric("Tiempo (s)", f"{metricas['tiempo_entrenamiento']:.2f}")
                                
                                # M√©tricas adicionales
                                with st.expander("M√©tricas Detalladas"):
                                    col_det1, col_det2 = st.columns(2)
                                    
                                    with col_det1:
                                        st.write(f"**MAPE:** {metricas['mape']:.4f}%")
                                        st.write(f"**Max Error:** {metricas['max_error']:.4f}")
                                        st.write(f"**CV R¬≤ Mean:** {metricas['cv_r2_mean']:.6f}")
                                    
                                    with col_det2:
                                        st.write(f"**CV R¬≤ Std:** {metricas['cv_r2_std']:.6f}")
                                        st.write(f"**Skewness:** {metricas['skewness']:.4f}")
                                        st.write(f"**Kurtosis:** {metricas['kurtosis']:.4f}")
                                
                                # Actualizar estado
                                st.session_state.modelos_hibridos_creados.append(resultado)
                                st.rerun()
                            else:
                                st.error(f"Error creando modelo h√≠brido: {resultado['error']}")
                    else:
                        st.error("Por favor completa todos los campos obligatorios")
        
        with col2:
            # Informaci√≥n de algoritmos base
            st.subheader("üß† Algoritmos Base Optimizados")
            
            for nombre, config in self.sistema.modelos_base_optimizados.items():
                with st.expander(f"**{nombre}**"):
                    st.write(f"**Peso inicial:** {config['peso_inicial']}")
                    st.write("**Par√°metros principales:**")
                    for param, valor in config['parametros'].items():
                        if param not in ['random_state', 'n_jobs']:
                            st.write(f"‚Ä¢ {param}: {valor}")
    
    def mostrar_tab_proyecciones_hibridas(self):
        """Mostrar tab para generar proyecciones h√≠bridas"""
        st.header("üìà Proyecciones H√≠bridas con An√°lisis de Incertidumbre")
        
        # Seleccionar modelo h√≠brido
        modelos_hibridos = self.sistema.listar_modelos_hibridos()
        
        if not modelos_hibridos:
            st.warning("No hay modelos h√≠bridos activos. Crea un modelo h√≠brido primero.")
            return
        
        col1, col2 = st.columns([2, 1])
        
        with col1:
            st.subheader("Configuraci√≥n de Proyecciones H√≠bridas")
            
            # Selector de modelo h√≠brido
            modelo_seleccionado = st.selectbox(
                "Seleccionar Modelo H√≠brido",
                [m['nombre'] for m in modelos_hibridos],
                format_func=lambda x: f"{x} ({next(m['tipo_hibrido'] for m in modelos_hibridos if m['nombre'] == x)})"
            )
            
            # Informaci√≥n del modelo seleccionado
            modelo_info = next(m for m in modelos_hibridos if m['nombre'] == modelo_seleccionado)
            
            col_info1, col_info2, col_info3, col_info4 = st.columns(4)
            
            with col_info1:
                st.metric("Tipo", modelo_info['tipo_hibrido'].replace('_', ' ').title())
            
            with col_info2:
                st.metric("Variable", modelo_info['variable_objetivo'].replace('_', ' ').title())
            
            with col_info3:
                st.metric("R¬≤", f"{modelo_info['r2']:.6f}")
            
            with col_info4:
                st.metric("Tiempo", f"{modelo_info['tiempo_entrenamiento']:.2f}s")
            
            # Configuraci√≥n de proyecci√≥n
            col_config1, col_config2 = st.columns(2)
            
            with col_config1:
                horizonte_dias = st.slider(
                    "Horizonte de Proyecci√≥n (d√≠as)",
                    min_value=1,
                    max_value=90,
                    value=30,
                    help="N√∫mero de d√≠as hacia el futuro para proyectar"
                )
            
            with col_config2:
                incluir_incertidumbre = st.checkbox(
                    "Incluir An√°lisis de Incertidumbre",
                    value=True,
                    help="Mostrar an√°lisis detallado de incertidumbre"
                )
            
            # Generar proyecciones h√≠bridas
            if st.button("Generar Proyecciones H√≠bridas", type="primary"):
                with st.spinner("Generando proyecciones h√≠bridas..."):
                    proyecciones = self.sistema.generar_proyecciones_hibridas(
                        modelo_seleccionado,
                        horizonte_dias,
                        incluir_incertidumbre
                    )
                    
                    if proyecciones:
                        st.session_state.proyecciones_hibridas_generadas[modelo_seleccionado] = proyecciones
                        st.success(f"Proyecciones h√≠bridas generadas: {len(proyecciones)} puntos")
                        st.rerun()
                    else:
                        st.error("Error generando proyecciones h√≠bridas")
        
        with col2:
            # Mostrar proyecciones si existen
            if modelo_seleccionado in st.session_state.proyecciones_hibridas_generadas:
                st.subheader("üìä Proyecciones H√≠bridas")
                
                proyecciones = st.session_state.proyecciones_hibridas_generadas[modelo_seleccionado]
                
                # Crear gr√°fico avanzado
                df_proyecciones = pd.DataFrame(proyecciones)
                df_proyecciones['fecha'] = pd.to_datetime(df_proyecciones['fecha'])
                
                fig = go.Figure()
                
                # L√≠nea principal
                fig.add_trace(go.Scatter(
                    x=df_proyecciones['fecha'],
                    y=df_proyecciones['valor_proyectado'],
                    mode='lines+markers',
                    name='Proyecci√≥n H√≠brida',
                    line=dict(color='blue', width=3),
                    marker=dict(size=6)
                ))
                
                # Intervalos de confianza
                if incluir_incertidumbre and 'intervalo_inferior' in df_proyecciones.columns:
                    fig.add_trace(go.Scatter(
                        x=df_proyecciones['fecha'],
                        y=df_proyecciones['intervalo_superior'],
                        mode='lines',
                        name='Confianza 95%',
                        line=dict(width=0),
                        showlegend=False
                    ))
                    
                    fig.add_trace(go.Scatter(
                        x=df_proyecciones['fecha'],
                        y=df_proyecciones['intervalo_inferior'],
                        mode='lines',
                        name='Intervalo Confianza',
                        line=dict(width=0),
                        fill='tonexty',
                        fillcolor='rgba(0,100,80,0.2)',
                        showlegend=True
                    ))
                
                fig.update_layout(
                    title=f"Proyecciones H√≠bridas: {modelo_info['variable_objetivo']}",
                    xaxis_title="Fecha",
                    yaxis_title=f"{modelo_info['variable_objetivo']}",
                    hovermode='x unified',
                    height=400
                , showlegend=False)
                
                st.plotly_chart(fig, config=PLOTLY_CONFIG, use_container_width=True)
                
                # An√°lisis de incertidumbre
                if incluir_incertidumbre:
                    st.subheader("üîç An√°lisis de Incertidumbre")
                    
                    col_inc1, col_inc2 = st.columns(2)
                    
                    with col_inc1:
                        # Gr√°fico de confianza temporal
                        fig_conf = px.line(
                            df_proyecciones, 
                            x='fecha', 
                            y='confianza',
                            title='Confianza por Horizonte Temporal'
                        )
                        fig_conf.update_layout(height=300)
                        st.plotly_chart(fig_conf, config=PLOTLY_CONFIG, use_container_width=True)
                    
                    with col_inc2:
                        # Gr√°fico de tipos de incertidumbre
                        fig_inc = go.Figure()
                        fig_inc.add_trace(go.Scatter(
                            x=df_proyecciones['fecha'],
                            y=df_proyecciones['incertidumbre_epistemica'],
                            mode='lines',
                            name='Incertidumbre Epist√©mica',
                            line=dict(color='red')
                        ))
                        fig_inc.add_trace(go.Scatter(
                            x=df_proyecciones['fecha'],
                            y=df_proyecciones['incertidumbre_aleatoria'],
                            mode='lines',
                            name='Incertidumbre Aleatoria',
                            line=dict(color='orange')
                        ))
                        fig_inc.update_layout(
                            title='Tipos de Incertidumbre',
                            height=300
                        )
                        st.plotly_chart(fig_inc, config=PLOTLY_CONFIG, use_container_width=True)
                
                # Tabla de proyecciones
                st.subheader("üìã Datos de Proyecci√≥n H√≠brida")
                
                df_mostrar = df_proyecciones[['fecha', 'valor_proyectado', 'confianza']].copy()
                if incluir_incertidumbre:
                    df_mostrar['intervalo_inferior'] = df_proyecciones['intervalo_inferior']
                    df_mostrar['intervalo_superior'] = df_proyecciones['intervalo_superior']
                
                df_mostrar['fecha'] = df_mostrar['fecha'].dt.strftime('%Y-%m-%d')
                df_mostrar['valor_proyectado'] = df_mostrar['valor_proyectado'].round(4)
                df_mostrar['confianza'] = (df_mostrar['confianza'] * 100).round(1).astype(str) + '%'
                
                if incluir_incertidumbre:
                    df_mostrar['intervalo_inferior'] = df_mostrar['intervalo_inferior'].round(4)
                    df_mostrar['intervalo_superior'] = df_mostrar['intervalo_superior'].round(4)
                
                st.dataframe(df_mostrar, use_container_width=True)
    
    def mostrar_tab_benchmark(self):
        """Mostrar tab de benchmark comparativo"""
        st.header("üèÜ Benchmark Comparativo de Modelos H√≠bridos")
        
        modelos_hibridos = self.sistema.listar_modelos_hibridos()
        
        if len(modelos_hibridos) < 2:
            st.warning("Necesitas al menos 2 modelos h√≠bridos para realizar benchmark.")
            return
        
        # An√°lisis comparativo
        st.subheader("üìä An√°lisis Comparativo de Rendimiento")
        
        df_modelos = pd.DataFrame(modelos_hibridos)
        
        # Gr√°fico de comparaci√≥n de R¬≤
        fig_r2 = px.bar(
            df_modelos,
            x='nombre',
            y='r2',
            title='Comparaci√≥n de R¬≤ por Modelo H√≠brido',
            color='r2',
            color_continuous_scale='Viridis'
        )
        fig_r2.update_layout(height=400)
        st.plotly_chart(fig_r2, config=PLOTLY_CONFIG, use_container_width=True)
        
        # Gr√°fico de comparaci√≥n de tiempo vs precisi√≥n
        fig_scatter = px.scatter(
            df_modelos,
            x='tiempo_entrenamiento',
            y='r2',
            size='rmse',
            color='tipo_hibrido',
            hover_data=['nombre'],
            title='Tiempo vs Precisi√≥n (Burbujas = RMSE)',
            labels={
                'tiempo_entrenamiento': 'Tiempo de Entrenamiento (s)',
                'r2': 'R¬≤ Score',
                'rmse': 'RMSE'
            }
        )
        fig_scatter.update_layout(height=400)
        st.plotly_chart(fig_scatter, config=PLOTLY_CONFIG, use_container_width=True)
        
        # Tabla de ranking
        st.subheader("üèÖ Ranking de Modelos H√≠bridos")
        
        # Calcular score compuesto (R¬≤ alto, RMSE bajo, tiempo bajo)
        df_modelos['score_compuesto'] = (
            df_modelos['r2'] * 0.5 + 
            (1 - df_modelos['rmse'] / df_modelos['rmse'].max()) * 0.3 +
            (1 - df_modelos['tiempo_entrenamiento'] / df_modelos['tiempo_entrenamiento'].max()) * 0.2
        )
        
        df_ranking = df_modelos.sort_values('score_compuesto', ascending=False)
        
        col_rank1, col_rank2, col_rank3 = st.columns(3)
        
        with col_rank1:
            st.metric("ü•á Mejor Modelo", df_ranking.iloc[0]['nombre'])
            st.metric("R¬≤", f"{df_ranking.iloc[0]['r2']:.6f}")
        
        with col_rank2:
            if len(df_ranking) > 1:
                st.metric("ü•à Segundo Lugar", df_ranking.iloc[1]['nombre'])
                st.metric("R¬≤", f"{df_ranking.iloc[1]['r2']:.6f}")
        
        with col_rank3:
            if len(df_ranking) > 2:
                st.metric("ü•â Tercer Lugar", df_ranking.iloc[2]['nombre'])
                st.metric("R¬≤", f"{df_ranking.iloc[2]['r2']:.6f}")
        
        # Tabla detallada
        st.subheader("üìã M√©tricas Detalladas")
        
        df_mostrar = df_ranking[['nombre', 'tipo_hibrido', 'variable_objetivo', 'r2', 'rmse', 'tiempo_entrenamiento', 'score_compuesto']].copy()
        df_mostrar['r2'] = df_mostrar['r2'].round(6)
        df_mostrar['rmse'] = df_mostrar['rmse'].round(6)
        df_mostrar['tiempo_entrenamiento'] = df_mostrar['tiempo_entrenamiento'].round(2)
        df_mostrar['score_compuesto'] = df_mostrar['score_compuesto'].round(4)
        
        st.dataframe(df_mostrar, use_container_width=True)
        
        # An√°lisis por tipo de h√≠brido
        st.subheader("üîç An√°lisis por Tipo de H√≠brido")
        
        tipo_stats = df_modelos.groupby('tipo_hibrido').agg({
            'r2': ['mean', 'std', 'count'],
            'rmse': ['mean', 'std'],
            'tiempo_entrenamiento': ['mean', 'std']
        }).round(6)
        
        st.dataframe(tipo_stats, use_container_width=True)
    
    def mostrar_tab_tecnicas_avanzadas(self):
        """Mostrar tab de t√©cnicas avanzadas"""
        st.header("üî¨ T√©cnicas Avanzadas de Modelos H√≠bridos")
        
        # Informaci√≥n sobre t√©cnicas
        st.subheader("üß† Algoritmos Base Optimizados")
        
        for nombre, config in self.sistema.modelos_base_optimizados.items():
            with st.expander(f"**{nombre}**"):
                st.write(f"**Descripci√≥n:** {config['clase'].__name__} con par√°metros ultra-optimizados")
                st.write(f"**Peso inicial:** {config['peso_inicial']}")
                st.write("**Par√°metros optimizados:**")
                for param, valor in config['parametros'].items():
                    if param not in ['random_state', 'n_jobs']:
                        st.write(f"‚Ä¢ `{param}`: {valor}")
        
        st.subheader("üîÑ Tipos de Modelos H√≠bridos")
        
        tipos_hibridos = {
            'Ensemble Optimizado': {
                'descripcion': 'Combina m√∫ltiples algoritmos con pesos optimizados autom√°ticamente',
                'ventajas': ['M√°xima precisi√≥n', 'Robusto', 'Optimizaci√≥n autom√°tica'],
                'casos_uso': 'Predicciones de alta precisi√≥n cuando el rendimiento es cr√≠tico'
            },
            'Stacking Avanzado': {
                'descripcion': 'Usa meta-aprendizaje para combinar predicciones de modelos base',
                'ventajas': ['Meta-aprendizaje', 'Captura relaciones complejas', 'Validaci√≥n cruzada'],
                'casos_uso': 'Datos complejos con relaciones no lineales entre variables'
            },
            'Voting Inteligente': {
                'descripcion': 'Voting regressor con pesos adaptativos seg√∫n rendimiento',
                'ventajas': ['R√°pido', 'Adaptativo', 'Balance precisi√≥n/velocidad'],
                'casos_uso': 'Aplicaciones en tiempo real que requieren velocidad'
            },
            'H√≠brido Adaptativo': {
                'descripcion': 'Selecciona autom√°ticamente el mejor modelo seg√∫n el contexto',
                'ventajas': ['Selecci√≥n autom√°tica', 'M√°xima velocidad', 'Adaptaci√≥n contextual'],
                'casos_uso': 'Sistemas que deben adaptarse a diferentes condiciones'
            }
        }
        
        for tipo, info in tipos_hibridos.items():
            with st.expander(f"**{tipo}**"):
                st.write(f"**Descripci√≥n:** {info['descripcion']}")
                
                st.write("**Ventajas:**")
                for ventaja in info['ventajas']:
                    st.write(f"‚Ä¢ {ventaja}")
                
                st.write(f"**Casos de uso:** {info['casos_uso']}")
        
        st.subheader("üìä T√©cnicas de Optimizaci√≥n")
        
        tecnicas = {
            'Selecci√≥n de Caracter√≠sticas': [
                'SelectKBest con f_regression',
                'RFE (Recursive Feature Elimination)',
                'PCA para reducci√≥n dimensional'
            ],
            'Preprocesamiento Avanzado': [
                'RobustScaler para datos con outliers',
                'PolynomialFeatures para interacciones',
                'Pipeline automatizado'
            ],
            'Optimizaci√≥n de Pesos': [
                'Minimizaci√≥n de RMSE',
                'L-BFGS-B para optimizaci√≥n num√©rica',
                'Normalizaci√≥n autom√°tica de pesos'
            ],
            'An√°lisis de Incertidumbre': [
                'Incertidumbre epist√©mica (del modelo)',
                'Incertidumbre aleatoria (ruido inherente)',
                'Intervalos de confianza del 95%'
            ]
        }
        
        for categoria, tecnicas_lista in tecnicas.items():
            with st.expander(f"**{categoria}**"):
                for tecnica in tecnicas_lista:
                    st.write(f"‚Ä¢ {tecnica}")
    
    def ejecutar_dashboard(self):
        """Ejecutar dashboard principal"""
        self.mostrar_header()
        
        # Sidebar
        config = self.mostrar_sidebar()
        
        # Tabs principales
        tab1, tab2, tab3, tab4 = st.tabs([
            "üöÄ Crear H√≠brido",
            "üìà Proyecciones H√≠bridas", 
            "üèÜ Benchmark",
            "üî¨ T√©cnicas Avanzadas"
        ])
        
        with tab1:
            self.mostrar_tab_crear_hibrido()
        
        with tab2:
            self.mostrar_tab_proyecciones_hibridas()
        
        with tab3:
            self.mostrar_tab_benchmark()
        
        with tab4:
            self.mostrar_tab_tecnicas_avanzadas()

def main():
    """Funci√≥n principal"""
    dashboard = DashboardModelosHibridosInnovadores()
    dashboard.ejecutar_dashboard()

if __name__ == "__main__":
    main()
