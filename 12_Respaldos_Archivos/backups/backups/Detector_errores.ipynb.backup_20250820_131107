{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "ffee8491-3521-42a7-b125-bc933a929cdc",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "C:\\Users\\Alicia_Piero\\Documents\\Repo_AIEP\\MIP_QUILLOTA\\Proyecto_METGO_3D\\notebooks\\Sistema_de_Pronostico_Meteorologico_y_Gestion_Agricola_MIP_Quillota.ipynb\n"
     ]
    }
   ],
   "source": [
    "import os\n",
    "\n",
    "# Carpeta ra√≠z de tu proyecto\n",
    "PROJECT_PATH = r\"C:\\Users\\Alicia_Piero\\Documents\\Repo_AIEP\\MIP_QUILLOTA\\Proyecto_METGO_3D\\notebooks\"\n",
    "\n",
    "# Nombre exacto del notebook\n",
    "NOTEBOOK_NAME = \"Sistema_de_Pronostico_Meteorologico_y_Gestion_Agricola_MIP_Quillota.ipynb\"\n",
    "\n",
    "# üëâ Ruta completa al notebook dentro de \\notebooks\n",
    "NOTEBOOK_PATH = os.path.join(PROJECT_PATH, NOTEBOOK_NAME)\n",
    "print(NOTEBOOK_PATH)\n",
    "# C:\\Users\\Alicia_Piero\\Documents\\Repo_AIEP\\MIP_QUILLOTA\\Proyecto_METGO_3D\\notebooks\\Sistema de Pron√≥stico Meteorol√≥gico y Gesti√≥n Agr√≠cola MIP Quillota.ipynb"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "70681763-5764-49ed-b779-f23224c4b619",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "True\n"
     ]
    }
   ],
   "source": [
    "import os\n",
    "print(os.path.exists(NOTEBOOK_PATH))   # deber√≠a devolver True"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "187383f7-1d6d-46fa-a531-311f498a68ed",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "üöÄ DETECTOR DE ERRORES - NOTEBOOK MIP QUILLOTA\n",
      "=================================================================\n",
      "üìÇ Proyecto: C:\\Users\\Alicia_Piero\\Documents\\Repo_AIEP\\MIP_QUILLOTA\\Proyecto_METGO_3D\\notebooks\n",
      "üìì Notebook: Sistema_de_Pronostico_Meteorologico_y_Gestion_Agricola_MIP_Quillota.ipynb\n",
      "\n",
      "üìã VERIFICACI√ìN INICIAL:\n",
      "-------------------------\n",
      "‚úÖ Notebook encontrado: True\n",
      "üìè Tama√±o del notebook: 0.90 MB\n",
      "‚úÖ Ejecut√°ndose en Jupyter Lab\n",
      "üîß Directorio actual: C:\\Users\\Alicia_Piero\\Documents\\Repo_AIEP\\MIP_QUILLOTA\\Proyecto_METGO_3D\n",
      "=================================================================\n"
     ]
    }
   ],
   "source": [
    "# ================================================================================================\n",
    "# DETECTOR DE ERRORES ESPEC√çFICO PARA TU NOTEBOOK\n",
    "# \"Sistema de Pron√≥stico Meteorol√≥gico y Gesti√≥n Agr√≠cola MIP Quillota.ipynb\"\n",
    "# ================================================================================================\n",
    "\n",
    "import os\n",
    "import sys\n",
    "import matplotlib.pyplot as plt\n",
    "import json\n",
    "import nbformat\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')\n",
    "\n",
    "\n",
    "print(\"üöÄ DETECTOR DE ERRORES - NOTEBOOK MIP QUILLOTA\")\n",
    "print(\"=\"*65)\n",
    "print(f\"üìÇ Proyecto: {PROJECT_PATH}\")\n",
    "print(f\"üìì Notebook: {NOTEBOOK_NAME}\")\n",
    "\n",
    "# Verificar si existe el notebook\n",
    "notebook_path = os.path.join(PROJECT_PATH, NOTEBOOK_NAME)\n",
    "notebook_exists = os.path.exists(notebook_path)\n",
    "\n",
    "print(f\"\\nüìã VERIFICACI√ìN INICIAL:\")\n",
    "print(\"-\"*25)\n",
    "print(f\"‚úÖ Notebook encontrado: {notebook_exists}\")\n",
    "\n",
    "if notebook_exists:\n",
    "    size_mb = os.path.getsize(notebook_path) / (1024 * 1024)\n",
    "    print(f\"üìè Tama√±o del notebook: {size_mb:.2f} MB\")\n",
    "else:\n",
    "    print(\"‚ùå El notebook no se encuentra en la ruta especificada\")\n",
    "    print(\"üîç Buscando archivos .ipynb en el directorio...\")\n",
    "    \n",
    "    import glob\n",
    "    notebooks = glob.glob(\"*.ipynb\")\n",
    "    if notebooks:\n",
    "        print(f\"üìì Notebooks encontrados:\")\n",
    "        for nb in notebooks:\n",
    "            print(f\"   - {nb}\")\n",
    "    else:\n",
    "        print(\"‚ùå No se encontraron notebooks en el directorio\")\n",
    "\n",
    "# Verificar entorno Jupyter\n",
    "try:\n",
    "    from IPython import get_ipython\n",
    "    from IPython.display import display, HTML, clear_output\n",
    "    \n",
    "    if get_ipython():\n",
    "        print(f\"‚úÖ Ejecut√°ndose en Jupyter Lab\")\n",
    "        print(f\"üîß Directorio actual: {os.getcwd()}\")\n",
    "    else:\n",
    "        print(f\"‚ùå No detectado entorno Jupyter\")\n",
    "        \n",
    "except ImportError:\n",
    "    print(f\"‚ùå Error importando IPython\")\n",
    "\n",
    "print(\"=\"*65)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "9861bd2d-0f47-4209-9ece-004c9789984d",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "üöÄ INICIANDO AN√ÅLISIS COMPLETO DEL NOTEBOOK...\n",
      "üìì AN√ÅLISIS DEL NOTEBOOK MIP QUILLOTA:\n",
      "----------------------------------------\n",
      "‚úÖ Notebook cargado exitosamente\n",
      "\n",
      "üèóÔ∏è  ESTRUCTURA DEL NOTEBOOK:\n",
      "------------------------------\n",
      "   üìä Total celdas: 32\n",
      "   üêç Celdas c√≥digo: 32\n",
      "   üìù Celdas markdown: 0\n",
      "   ‚ö™ Celdas vac√≠as: 2\n",
      "   üîß Kernel: Python 3 (ipykernel)\n",
      "   üêç Lenguaje: python\n",
      "\n",
      "üì¶ IMPORTS Y DEPENDENCIAS:\n",
      "------------------------------\n",
      "   üìã Total imports √∫nicos: 83\n",
      "   üêç Librer√≠as est√°ndar: 8\n",
      "   üìä Librer√≠as data science: 17\n",
      "   üå§Ô∏è  Librer√≠as meteorol√≥gicas: 0\n",
      "   üìö Otras librer√≠as: 58\n",
      "   ‚ùå Librer√≠as cr√≠ticas faltantes: ['matplotlib']\n",
      "\n",
      "   üìä Principales imports data science:\n",
      "      ‚Ä¢ from sklearn.cluster import KMeans\n",
      "      ‚Ä¢ from sklearn.ensemble import RandomForestClassifier\n",
      "      ‚Ä¢ from sklearn.ensemble import RandomForestRegressor\n",
      "      ‚Ä¢ from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor\n",
      "      ‚Ä¢ from sklearn.ensemble import RandomForestRegressor, RandomForestClassifier\n",
      "\n",
      "üìä MANEJO DE DATOS:\n",
      "--------------------\n",
      "   ‚úÖ Lectura Datos: 1 celdas\n",
      "   ‚úÖ Limpieza Datos: 3 celdas\n",
      "   ‚ùå Transformacion: No encontrado\n",
      "   ‚úÖ Visualizacion: 4 celdas\n",
      "\n",
      "üå§Ô∏è  AN√ÅLISIS METEOROL√ìGICO:\n",
      "-------------------------\n",
      "   ‚úÖ Variables Meteo: 5 t√©rminos\n",
      "      temperatura, viento, precipitacion, presion, humedad\n",
      "   ‚úÖ Unidades: 7 t√©rminos\n",
      "      ¬∞c, hpa, celsius, mb, fahrenheit\n",
      "   ‚úÖ Estaciones: 4 t√©rminos\n",
      "      invierno, verano, primavera, oto√±o\n",
      "   ‚úÖ Agricola: 6 t√©rminos\n",
      "      cosecha, cultivo, siembra, quillota, riego\n",
      "\n",
      "   üîç Verificaci√≥n de rangos meteorol√≥gicos:\n",
      "      ‚Ä¢ Temperatura detectada en celda 4\n",
      "      ‚Ä¢ Temperatura detectada en celda 5\n",
      "      ‚Ä¢ Temperatura detectada en celda 6\n",
      "      ‚Ä¢ Precipitacion detectada en celda 6\n",
      "      ‚Ä¢ Temperatura detectada en celda 7\n",
      "      ‚Ä¢ Humedad detectada en celda 7\n",
      "      ‚Ä¢ Temperatura detectada en celda 8\n",
      "      ‚Ä¢ Temperatura detectada en celda 11\n",
      "      ‚Ä¢ Temperatura detectada en celda 13\n",
      "      ‚Ä¢ Temperatura detectada en celda 16\n",
      "      ‚Ä¢ Humedad detectada en celda 16\n",
      "      ‚Ä¢ Precipitacion detectada en celda 16\n",
      "      ‚Ä¢ Temperatura detectada en celda 17\n",
      "      ‚Ä¢ Humedad detectada en celda 17\n",
      "      ‚Ä¢ Temperatura detectada en celda 19\n",
      "      ‚Ä¢ Temperatura detectada en celda 20\n",
      "      ‚Ä¢ Temperatura detectada en celda 22\n",
      "      ‚Ä¢ Humedad detectada en celda 22\n",
      "      ‚Ä¢ Precipitacion detectada en celda 22\n",
      "      ‚Ä¢ Temperatura detectada en celda 29\n",
      "      ‚Ä¢ Temperatura detectada en celda 30\n",
      "\n",
      "ü§ñ MODELOS DE MACHINE LEARNING:\n",
      "--------------------------------\n",
      "   ‚úÖ Indicadores de ML encontrados: 11\n",
      "      ‚Ä¢ Sklearn Models: 5 celdas\n",
      "      ‚Ä¢ Model Evaluation: 3 celdas\n",
      "      ‚Ä¢ Preprocessing: 2 celdas\n",
      "      ‚Ä¢ Deep Learning: 1 celdas\n",
      "\n",
      "üîç VERIFICACI√ìN DE ERRORES COMUNES:\n",
      "-----------------------------------\n",
      "   ‚ö†Ô∏è  Problemas encontrados: 40\n",
      "      ‚Ä¢ Celda 2: Muchos imports en una celda\n",
      "      ‚Ä¢ Celda 2: Celda muy larga (3601 caracteres)\n",
      "      ‚Ä¢ Celda 3: Celda muy larga (6304 caracteres)\n",
      "      ‚Ä¢ Celda 4: Muchos imports en una celda\n",
      "      ‚Ä¢ Celda 4: Celda muy larga (41219 caracteres)\n",
      "      ‚Ä¢ Celda 4: Ruta hardcodeada detectada\n",
      "      ‚Ä¢ Celda 5: Muchos imports en una celda\n",
      "      ‚Ä¢ Celda 5: Celda muy larga (44654 caracteres)\n",
      "      ‚Ä¢ Celda 6: Muchos imports en una celda\n",
      "      ‚Ä¢ Celda 6: Celda muy larga (46731 caracteres)\n",
      "\n",
      "=================================================================\n",
      "\n",
      "üìã REPORTE FINAL DEL AN√ÅLISIS:\n",
      "===================================\n",
      "üìä Resumen:\n",
      "   ‚ùå Errores cr√≠ticos: 1\n",
      "   ‚ö†Ô∏è  Advertencias: 40\n",
      "\n",
      "‚ùå ERRORES CR√çTICOS QUE REQUIEREN ATENCI√ìN:\n",
      "   1. Librer√≠as cr√≠ticas faltantes: ['matplotlib']\n",
      "\n",
      "‚ö†Ô∏è  ADVERTENCIAS PRINCIPALES:\n",
      "   1. Celda 2: Muchos imports en una celda\n",
      "   2. Celda 2: Celda muy larga (3601 caracteres)\n",
      "   3. Celda 3: Celda muy larga (6304 caracteres)\n",
      "   4. Celda 4: Muchos imports en una celda\n",
      "   5. Celda 4: Celda muy larga (41219 caracteres)\n",
      "   6. Celda 4: Ruta hardcodeada detectada\n",
      "   7. Celda 5: Muchos imports en una celda\n",
      "   8. Celda 5: Celda muy larga (44654 caracteres)\n",
      "   9. Celda 6: Muchos imports en una celda\n",
      "   10. Celda 6: Celda muy larga (46731 caracteres)\n",
      "\n",
      "üí° SUGERENCIAS DE MEJORA:\n",
      "   1. Revisar y corregir errores cr√≠ticos primero\n",
      "   2. Agregar documentaci√≥n en celdas markdown\n",
      "   3. Organizar imports en una sola celda al inicio\n",
      "   4. Eliminar celdas de c√≥digo vac√≠as\n",
      "   5. Validar rangos de datos meteorol√≥gicos\n",
      "   6. Agregar manejo de errores (try-except)\n",
      "   7. Usar rutas relativas en lugar de absolutas\n",
      "   8. Limpiar outputs grandes innecesarios\n",
      "   9. Agregar validaci√≥n de datos de entrada\n",
      "   10. Documentar par√°metros de modelos ML\n",
      "=================================================================\n"
     ]
    },
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAkIAAAHHCAYAAABTMjf2AAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjguMiwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy8g+/7EAAAACXBIWXMAAA9hAAAPYQGoP6dpAAAxSElEQVR4nO3dD3zO9f7/8deMbVQbWgwN5b+EMoTkKLWTfznVyaFjS6I/TjmcFNGkhEpSWYn86ZwS/aGEo7RIoiPGOSl/DqqpbKyyiRjb53t7vX+/z8617do/bbuuXe/H/Xa72PW5Pp/rel+fz7V9ntf73yfIcRxHAAAALFTF1wUAAADwFYIQAACwFkEIAABYiyAEAACsRRACAADWIggBAABrEYQAAIC1CEIAAMBaBCGghLZu3SqTJ0+Ww4cP+7ooKAfLli2TGTNmSHZ2tq+LAqACEYSAEvjxxx/lD3/4g5w+fVrq1KmT57FFixZJUFCQfPPNN7nLfve735lbaXh7HpSN2267TRo3blzo45s2bZJbb71VWrduLcHBwWf1GrYfP2/7WPfHI488knvf9n0E/0QQQkB54YUXzB/azp07l9lz6lVo4uPjTbCZMmWKVAZaVt0PzZo18/r42rVrzeN6e+utt0r9/D/88IM5we3YsUMCIeT+6U9/kueee0569+4tgU7f79ixY6VFixYSFhYmtWvXltjYWFm1apX4s8WLF8usWbN8XQwEIIIQAsprr71mvpVu2bJF9u3bVybP+fXXX8uVV14p8+fPL/E2H3zwgbmVxpAhQ+TXX3+VRo0aSVnQk5zuA90X3vaTPn62NAhpM2EgBKHt27ebgDt8+PDf9DxlffzKw549e6Rdu3Ym9PXs2VNmz54tDz30kGnu7du3r4wbN+6sn3vevHnm+csLQQjlhSCEgKGBRZs4Zs6cKRdccIE52ZeFiy++2JwgQkJCSryNrlua9ZU2yWg40VqastCkSRPzrf/111/Ps/zkyZOyfPly6dOnj1RWx48fL7Pn6tWrl8TFxf3m5ynr41fWtFn35ptvlp9//lk2bNggc+bMkTvuuEPuv/9+0/9t4MCB8sQTT8ibb755Vs9frVo1CQ0NLfNyA+WNIISAocGnVq1a5gSvf/C9BSHtm6AnKu0UO3fuXBMW9I93x44d5fPPP8+z7n/+8x/T70GDkJ7goqKi5PbbbzdNC8Xx1kfo+eefl0suuURq1KhhyhkTE2O+5RbVf0JPUNpsERkZKdWrV5eLLrrIlKGkBg0aJEuXLpWcnJzcZe+9956cOHFCbrnlFq/bfP/99+Y16tata/aNlnnBggW5j69fv97sLzV06NDcJjYtv+tf//qX/P73v5eIiAjzfnv06CGffvqp19qY66+/XsLDw+Xcc8+Va665Rj777LM867j75eOPP5Z77rnH9NG68MIL8zSHahm1rPXr15eRI0fK0aNHSxSm/va3v0l0dLTZVkOjfi60KdST1vLcd9995hicd9550r9/f7OPStr/5Z///Kd5/7qtvk/dd57HXWn46NChgznG+jp//vOfzWuUpbffflt27txpQn3+pmMNcS+99JLUrFlTJk2aVOx70s+ALtf/S9oPqyjFHUP9XdKmu2+//Tb38+a+VlZWliQkJJj9p5+3c845R7p37y7r1q07q7LAPlV9XQCgrGjwufHGG01NjAaAF1980YQb96TtSU9Ex44dkzvvvNP8UX3yySfNtgcOHDDfbN1+NPv37zcnew1BehLR8PTll1+ak3Vpvvlrs4GeTDWgjRo1ytTKaNDSwDB48GCv22hzxXXXXWdqt/TkpScpPSHp6KaS0ufWk7WesK6++urc966BI3+nb5WWliZXXHGFeW9/+ctfzGvriXzYsGGSmZkpf/3rX6VVq1by6KOPmpPPiBEjzElHde3a1fz/0UcfmXCjJyY9qVapUkUWLlxoXv+TTz6RTp06mfV0P+q2Gg4eeOABs9/1ZKwnPQ09+U/WGoK0PPq6bo2QvjdtotNanbvvvts0zbjHXYOXeyzz07CjgUZPlvre2rdvL++//77pO6MB5Jlnnslzgn/jjTdM05fuGy1bSWvTNEhoqNST/Pjx480x1PC3Zs2a3OOu6+hnTD+n06ZNM8fg2WefNeXXdXWbsqABWBVW+6Uh4oYbbpBXXnnFfO71S0JFKMkxnDBhgmRkZMh3332Xe2w0OCv9XL788svmd16bN/X3Wpux9QuENgvrsQWK5AABYOvWrfo13lm7dq25n5OT41x44YXOqFGj8qz39ddfm/XOP/9856effspd/u6775rl7733Xu6yX375pcDrvPrqq2a9DRs25C5buHChWabP7erRo4e5uW644QbnkksuKfI95H+e5cuXm/uff/55KffG/3t99/ViYmKcYcOGmZ9//vlnJyQkxHnllVecdevWmed/8803c7fT9erVq+ekp6fneb4//elPTkREhHPixAlzX8uk22qZPel+b9asmRMbG2t+dul2F110kXPttdfmLhswYIApy/79+3OX/fDDD855553nXHXVVQX2y5VXXumcOXMmd/nhw4fN9tddd52TnZ2du3z27Nlm/QULFuQui4+Pdxo1apR7/5133jHrTJkyJU/5b775ZicoKMjZt2+fub9t2zaz3l//+tc86912221m+aRJkwo9fkePHjXvpXPnzs6vv/5aYD+prKwsp06dOk6bNm3yrLNy5UrzXAkJCU5Zad++vTmGRZk5c6Z53RUrVnh9Ty73s6P/F7aPVXH7qDTHsE+fPgWeX+ln4tSpU3mW6ee8bt26zu23317sfgFoGkPA1AZpU452AFVao6F9HpYsWeJ1Xhh9TJunXG6thtYIubSK3aV/07UWR2toVHJycqnKp9/q9dts/ua34rZRK1euNP07zpbWPGgtkjYh6AgxbQbRqQDy0/eozSf9+vUzP6enp+fe9Nu1fiMv7n1r5+n//ve/5jW1CdHdXmtwtBZK+6ZoM50eE+1MPmDAANP06KpXr57ZduPGjeabvif9tu85tP3DDz8070lrqbTWyXM9rWUqahTU6tWrzXNpLZ0nbSrT9661YEprbtzaKE/33nuvFEdrFLV2Qmvz8ndMd2sTtelTa/70+T3X0Rqnli1blulILi2LNs8VxX1c160Iv+UYuvQ4uv3x9LP1008/yZkzZ0zTc2l/T2EnghAqPT2pauDREKQdpnWklN60aUWbGZKSkgps07Bhwzz33VCkHUldeuLX5gy3j5D233Cbk/Sx0njwwQdNVb42C+mQdu0D4a3PjCftV3LTTTeZZgPtN6LNFtrEdOrUqVK9tg4N1/LqyV0Do44O8nZCPHLkiOmXoc1/2gTledOmG1XcZJIagpRON5D/ObT5QsuuZdHX0n5K2i8nP2160xPawYMH8yzX/lGetL+Iyv8celLUY+Y+7o0+pn1R8u8HfW3P59b/9QSd/7WbNm0qxdHmJdWmTZsiy+HtPSgNQkW9B/3cp6am5rlpqCiMvtfiAo77uLdm0/LwW46hJ23Oa9u2rfk9Pf/8883nTUNUaX9PYSf6CKHS0z4phw4dMmFIb/npyd+tyXEVNmmeZ0dZrTXSsDJx4kS5/PLLTZDRk4/WHnl2Pi4JPcFq3wet3dFaBq150Q6i2t9Fg4437hw/2h9J+3doHxbtb/L000+bZW4fieJoLYv2u9Ht9P3oa3vjviftqKtBxhs92RTFfY6nnnqq0L4ZWu7ShjmlQRT/o0Exf0DTPk+FTeSpk0VqjV1KSkqBLwIu7bem3Fq6wvrB+dPs26+++qrpx6W1i9rHS0Oc/n5rfys3jAJFIQih0tOgo3/8EhMTCzymTUI6VFyHCpfmRKo1Ixo8dH4Zrc1x7d2796zLqU1tGq70pt/ctXP2448/bmqdiprTRzvo6k3X1Y7OOgOyBj4d+lxS2tyk62tzW2GTBuq3aK010JOcdlwtSmEnSLeDrTZrFPUc+lo6mszbvDO7d+82tTA6mqso7nw9+hyezWu6b7VmsKjX1221WSZ/c5G+tudz6/8a7vT5PCenLMkcVe6+0E72hdUgeb4HtzO7S5cVNSeRduDX5jdPOkdQYbTJUz8/f//73024z0+bIt99910T+t396daU5h+FV9KamuKU5hgW9pnTLwu6rf6ue67jOfoNKApNY6jUdGiz/gHU5h4dkZX/piOf9GS3YsWKUj2v218hf98crVU5G/mH3GvVv35D1xqowvr/aDNd/qHcbi1LaWtUdF/oiUFroQqb30i/RWtTnDvMOj9tzsrffyr/CVJHimkA0GHov/zyS6HPoa+ltXR64vUcmq1NmXqy1gksNUwVRU+S+l50ckDP/aQjhrRJpKiRXRoGNfDphIKedESSnkx11JvSvlFK91v+qRCKo+9PQ5bWTGj/Mk9uebUfi4Z4Deqex1SbMXft2lXke9DwrPvA8+bZ7y0/PbY6em369Ommb5InDXs6Yks/czpCK3+Y075dLt1v2nxaFkpzDPUz562py63d9dxeR2Nu3ry5TMqIwEeNECo1DTgadHQotDdak+JOrqg1MSWlJ2E9GWsTj3a8bNCggakh0maFs6EnRf0G361bN9OpW09yehLWP/SFdWDVfg96AtaOzXpC0vepw/C1bKW9FIQOjfac86YwepLU5hXtX6UdVjWsaedT7XSqNSj6s9LyaO2SnsC1/HqS0m20qUb7AmmQ0JOu9i3SfadD0vV5tezuMG6tbdMaDd3P2lm4atWqZvi8BgKdzqA4ely1Nk2bFnXOIv0MaM2C7jMdiq5NfEXVjmifMj3paxDTmhTtvK3BTDvuugFAg50GCJ3RWMOsO3zerRksagoFfa8arLQmTsujtXIaVP7973+b/lF6fHVouE5iqPtJ+4TpEHB3+LzOkzN69GgpK/paGnK15kn3ub6mBjENsxo+9RjrLNNaU+nSY6jvWfezHnu9HIfWRurvRFkozTHUY6FzYo0ZM8Y8pk2sehz1S5B+GdLfE/190pok/VzqZ9dbGAcK8PWwNeC36NevnxMWFuYcP3680HV0qHO1atXMkHB3+PxTTz1VYL38Q31TUlLMEG8dclyzZk0zhDw1NbXYIcHehs+/9NJLZki4DtsPDQ11mjRp4owdO9bJyMgo9HmSk5OdQYMGOQ0bNjTb6DDrvn37mqkCSjN8vjDehs+rtLQ0Z+TIkU50dLTZb1FRUc4111zjzJ07N896OuVA69atnapVqxYYSr99+3bnxhtvzH2/Ouz5lltucZKSkvI8h75HHWp/7rnnOjVq1HB69uzpbNq0Kc867n4pbBoBHWrdsmVLU1YdMn333Xeb4dOevA3tPnbsmDN69Ginfv36Zlsd9q+fC89h/0o/W7o/ateubcqpn4k9e/aYMk2fPr1AOfMPNdeh6F27dnWqV6/uhIeHO506dXJef/31POssXbrUueyyy8y+0te59dZbne+++84pD0eOHHH+9re/OU2bNjVD17XMeps/f77X9XV6g169epmy6f596KGHzDQVZTF8vjTHUKezGDx4sPld1OdwX0uP19SpU819LaPuR51+wFt5AG+C9J+C8QgAUBjtdHzZZZeZjrraZ6sy++KLL8wAAO2TpdMWaO0hYBP6CAFAMf3Q8tOmMu1HdtVVV0lld+mll5omQZ36QEdeFTUEHwhE9BECgCJof6Vt27aZPkXaj0k7MutNLy9S3Mi2ykL7J+Xv0A3YgqYxACiCdujWzrxfffWV6Xyrc/Dodce0o7UGIwCVm0+bxnRIpvb61xledfTFO++8U+w2evFInedCr1Ksc3N4XvEaAMratddea/rO6KgpbTbSOYR0KgJCEBAYfBqE9PpDOmzV20R43uiwSB0eqVXU2llRh7nq0FQd1gwAAFBpm8a0RkhnANbOeoXRGX71+jGek73pdZR0Hgz34ogAAAAlVanqdnWm0PzT5uvMr1ozVBidnM1zxlb36sR6Yb6iJkMDAAD+Q+ttdGJZ7U7jzv5vXRDSqyvrrLye9L5eI0eHuHq7lpROb1/YRS0BAEDlu+DwhRdeaGcQOhs6fbtOye7Sa9XoqA/dkcVdywgAAPgHrfTQKSsKuyyRFUFIr9Wk1+HxpPc10BR2ZXEdXaa3/HQbghAAAJVLWXdrqVQzS3fp0kWSkpIKzPGhywEAACpVENLJyXQYvN7c4fH6s3uFb23WiouLy13/rrvukgMHDsgDDzwgu3fvNlcofuONN8r0Cs0AAMAePg1CW7duNRcu1JvSvjz6c0JCgrl/6NCh3FCkLrroIjN8XmuBdP6hp59+Wl5++WUzcgwAAKDSziNUkZ2t9OrK2mmaPkIAANh9/q5UfYQAAADKEkEIAABYiyAEAACsRRACAADWIggBAABrEYQAAIC1CEIAAMBaBCEAAGAtghAAALAWQQgAAFiLIAQAAKxFEAIAANYiCAEAAGsRhAAAgLUIQgAAwFoEIQAAYC2CEAAAsBZBCAAAWIsgBAAArEUQAgAA1iIIAQAAaxGEAACAtQhCAADAWgQhAABgLYIQAACwFkEIAABYiyAEAACsRRACAADWIggBAABrEYQAAIC1CEIAAMBaBCEAAGAtghAAALAWQQgAAFiLIAQAAKxFEAIAANYiCAEAAGsRhAAAgLUIQgAAwFoEIQAAYC2CEAAAsBZBCAAAWIsgBAAArEUQAgAA1iIIAQAAaxGEAACAtQhCAADAWgQhAABgLYIQAACwFkEIAABYiyAEAACsRRACAADWIggBAABrEYQAAIC1CEIAAMBaBCEAAGAtghAAALAWQQgAAFiLIAQAAKxFEAIAANYiCAEAAGsRhAAAgLUIQgAAwFo+D0KJiYnSuHFjCQsLk86dO8uWLVuKXH/WrFnSokULqV69ukRHR8vo0aPl5MmTFVZeAAAQOHwahJYuXSpjxoyRSZMmSXJysrRr105iY2Pl8OHDXtdfvHixjBs3zqy/a9cumT9/vnmOhx56qMLLDgAAKj+fBqGZM2fK8OHDZejQodK6dWuZM2eO1KhRQxYsWOB1/U2bNkm3bt1k8ODBphbpuuuuk0GDBhVbiwQAAOBXQSgrK0u2bdsmvXr1+l9hqlQx9zdv3ux1m65du5pt3OBz4MABWb16tfTu3bvQ1zl16pRkZmbmuQEAAKiqvtoN6enpkp2dLXXr1s2zXO/v3r3b6zZaE6TbXXnlleI4jpw5c0buuuuuIpvGpk2bJpMnTy7z8gMAgMrP552lS2P9+vUydepUeeGFF0yfomXLlsmqVavkscceK3Sb8ePHS0ZGRu7t4MGDFVpmAADgv3xWIxQZGSnBwcGSlpaWZ7nej4qK8rrNww8/LEOGDJE77rjD3L/00kvl+PHjMmLECJkwYYJpWssvNDTU3AAAAPymRigkJEQ6dOggSUlJuctycnLM/S5dunjd5sSJEwXCjoYppU1lAAAAlaJGSOnQ+fj4eImJiZFOnTqZOYK0hkdHkam4uDhp0KCB6eej+vXrZ0aaXXbZZWbOoX379plaIl3uBiIAAIBKEYQGDhwoR44ckYSEBElNTZX27dvLmjVrcjtQp6Sk5KkBmjhxogQFBZn/v//+e7ngggtMCHr88cd9+C4AAEBlFeRY1qakw+cjIiJMx+nw8HBfFwcAAPjw/F2pRo0BAACUJYIQAACwFkEIAABYiyAEAACsRRACAADWIggBAABrEYQAAIC1CEIAAMBaBCEAAGAtghAAALAWQQgAAFiLIAQAAKxFEAIAANYiCAEAAGsRhAAAgLUIQgAAwFoEIQAAYC2CEAAAsBZBCAAAWIsgBAAArEUQAgAA1iIIAQAAaxGEAACAtQhCAADAWgQhAABgLYIQAACwFkEIAABYiyAEAACsRRACAADWIggBAABrEYQAAIC1CEIAAMBaBCEAAGAtghAAALAWQQgAAFiLIAQAAKxFEAIAANYiCAEAAGsRhAAAgLUIQgAAwFoEIQAAYC2CEAAAsBZBCAAAWIsgBAAArEUQAgAA1iIIAQAAaxGEAACAtQhCAADAWgQhAABgLYIQAACwFkEIAABYiyAEAACsRRACAADWIggBAABrEYQAAIC1CEIAAMBaBCEAAGAtghAAALAWQQgAAFiLIAQAAKxFEAIAANYiCAEAAGsRhAAAgLV8HoQSExOlcePGEhYWJp07d5YtW7YUuf7Ro0dl5MiRUq9ePQkNDZXmzZvL6tWrK6y8AAAgcFT15YsvXbpUxowZI3PmzDEhaNasWRIbGyt79uyROnXqFFg/KytLrr32WvPYW2+9JQ0aNJBvv/1Watas6ZPyAwCAyi3IcRzHVy+u4adjx44ye/Zscz8nJ0eio6Pl3nvvlXHjxhVYXwPTU089Jbt375Zq1aqd1WtmZmZKRESEZGRkSHh4+G9+DwAAoPyV1/nbZ01jWruzbds26dWr1/8KU6WKub9582av26xYsUK6dOlimsbq1q0rbdq0kalTp0p2dnahr3Pq1Cmz8zxvAAAAPg1C6enpJsBooPGk91NTU71uc+DAAdMkpttpv6CHH35Ynn76aZkyZUqhrzNt2jSTIN2b1jgBAAD4RWfp0tCmM+0fNHfuXOnQoYMMHDhQJkyYYJrMCjN+/HhTjebeDh48WKFlBgAA/stnnaUjIyMlODhY0tLS8izX+1FRUV630ZFi2jdIt3O1atXK1CBpU1tISEiBbXRkmd4AAAD8pkZIQ4vW6iQlJeWp8dH72g/Im27dusm+ffvMeq69e/eagOQtBAEAAPht05gOnZ83b5688sorsmvXLrn77rvl+PHjMnToUPN4XFycadpy6eM//fSTjBo1ygSgVatWmc7S2nkaAACgUs0jpH18jhw5IgkJCaZ5q3379rJmzZrcDtQpKSlmJJlLOzq///77Mnr0aGnbtq2ZR0hD0YMPPujDdwEAACorn84j5AvMIwQAQOWTGWjzCAEAAPgaQQgAAFiLIAQAAKxFEAIAANYiCAEAAGsRhAAAgLUIQgAAwFoEIQAAYC2CEAAAsBZBCAAAWIsgBAAArEUQAgAA1iIIAQAAaxGEAACAtUoVhBzHkZSUFDl58mT5lQgAAMBfg1DTpk3l4MGD5VciAAAAfwxCVapUkWbNmsmPP/5YfiUCAADw1z5C06dPl7Fjx8rOnTvLp0QAAAAVJMjR9q5SqFWrlpw4cULOnDkjISEhUr169TyP//TTT+LPMjMzJSIiQjIyMiQ8PNzXxQEAAD48f1ct7QazZs0qsxcHAADwpVIHofj4+PIpCQAAgL8HIZWdnS3vvPOO7Nq1y9y/5JJLpH///hIcHFzW5QMAAPCfILRv3z7p3bu3fP/999KiRQuzbNq0aRIdHS2rVq2SJk2alEc5AQAAfD9q7L777jNhR+cSSk5ONjedZPGiiy4yjwEAAARsjdDHH38sn332mdSuXTt32fnnn2+G1Xfr1q2sywcAAOA/NUKhoaFy7NixAst/+eUXM5weAAAgYINQ3759ZcSIEfKvf/3LXHJDb1pDdNddd5kO0wAAAAEbhJ577jnTR6hLly4SFhZmbtokptcge/bZZ8unlAAAAP7QR6hmzZry7rvvyn//+1/ZvXu3WdaqVSsThAAAAAJ+HiGlF1/VGwAAQEAHoTFjxpT4CWfOnPlbygMAAOBfQWj79u0lerKgoKDfWh4AAAD/CkLr1q0r/5IAAAD4+6gxAAAAqztLb926Vd544w1zaY2srKw8jy1btqysygYAAOBfNUJLliyRrl27mivPL1++XE6fPi1ffvmlfPTRRxIREVE+pQQAAPCHIDR16lR55pln5L333jOX1NBJFHU+oVtuuUUaNmxYHmUEAADwjyC0f/9+6dOnj/lZg9Dx48fNaLHRo0fL3Llzy6OMAAAA/hGEatWqlXvR1QYNGsjOnTvNz0ePHpUTJ06UfQkBAAB8HYTcwHPVVVfJ2rVrzc9//OMfZdSoUTJ8+HAZNGiQXHPNNeVVTgAAAN+NGmvbtq107NhRBgwYYAKQmjBhglSrVk02bdokN910k0ycOLHsSwgAAFBOghzHcUqy4ieffCILFy6Ut956S3JyckzwueOOO6R79+5SmWRmZprRbRkZGRIeHu7r4gAAAB+ev0vcNKaBZ8GCBXLo0CF5/vnn5ZtvvpEePXpI8+bN5YknnpDU1NQyKxQAAIBfdpY+55xzZOjQofLxxx/L3r17TTNZYmKiGTrfv3//8iklAACAL5vGCqPD51977TUZP368GTmWnZ0t/oymMQAAKp/Mcjp/n9UlNtSGDRtMU9nbb78tVapUMRMqDhs2rMwKBgAAUN5KFYR++OEHWbRokbnt27fPXGrjueeeMyFIm8wAAAACMghdf/318uGHH0pkZKTExcXJ7bffLi1atCjf0gEAAPhDENL5gnTofN++fSU4OLg8ywQAAOBfQWjFihXlWxIAAAB/Hz4PAAAQKAhCAADAWgQhAABgLYIQAACwFkEIAABYiyAEAACsRRACAADWIggBAABrEYQAAIC1CEIAAMBaBCEAAGAtghAAALAWQQgAAFjLL4JQYmKiNG7cWMLCwqRz586yZcuWEm23ZMkSCQoKkgEDBpR7GQEAQODxeRBaunSpjBkzRiZNmiTJycnSrl07iY2NlcOHDxe53TfffCP333+/dO/evcLKCgAAAovPg9DMmTNl+PDhMnToUGndurXMmTNHatSoIQsWLCh0m+zsbLn11ltl8uTJcvHFF1doeQEAQODwaRDKysqSbdu2Sa9evf5XoCpVzP3NmzcXut2jjz4qderUkWHDhhX7GqdOnZLMzMw8NwAAAJ8HofT0dFO7U7du3TzL9X5qaqrXbTZu3Cjz58+XefPmleg1pk2bJhEREbm36OjoMik7AACo/HzeNFYax44dkyFDhpgQFBkZWaJtxo8fLxkZGbm3gwcPlns5AQBA5VDVly+uYSY4OFjS0tLyLNf7UVFRBdbfv3+/6STdr1+/3GU5OTnm/6pVq8qePXukSZMmebYJDQ01NwAAAL+qEQoJCZEOHTpIUlJSnmCj97t06VJg/ZYtW8oXX3whO3bsyL31799fevbsaX6m2QsAAFSaGiGlQ+fj4+MlJiZGOnXqJLNmzZLjx4+bUWQqLi5OGjRoYPr66DxDbdq0ybN9zZo1zf/5lwMAAPh9EBo4cKAcOXJEEhISTAfp9u3by5o1a3I7UKekpJiRZAAAAGUtyHEcRyyiw+d19Jh2nA4PD/d1cQAAgA/P31S1AAAAaxGEAACAtQhCAADAWgQhAABgLYIQAACwFkEIAABYiyAEAACsRRACAADWIggBAABrEYQAAIC1CEIAAMBaBCEAAGAtghAAALAWQQgAAFiLIAQAAKxFEAIAANYiCAEAAGsRhAAAgLUIQgAAwFoEIQAAYC2CEAAAsBZBCAAAWIsgBAAArEUQAgAA1iIIAQAAaxGEAACAtQhCAADAWgQhAABgLYIQAACwFkEIAABYiyAEAACsRRACAADWIggBAABrEYQAAIC1CEIAAMBaBCEAAGAtghAAALAWQQgAAFiLIAQAAKxFEAIAANYiCAEAAGsRhAAAgLUIQgAAwFoEIQAAYC2CEAAAsBZBCAAAWIsgBAAArEUQAgAA1iIIAQAAaxGEAACAtQhCAADAWgQhAABgLYIQAACwFkEIAABYiyAEAACsRRACAADWIggBAABrEYQAAIC1CEIAAMBaBCEAAGAtghAAALAWQQgAAFiLIAQAAKzlF0EoMTFRGjduLGFhYdK5c2fZsmVLoevOmzdPunfvLrVq1TK3Xr16Fbk+AACA3wahpUuXypgxY2TSpEmSnJws7dq1k9jYWDl8+LDX9devXy+DBg2SdevWyebNmyU6Olquu+46+f777yu87AAAoHILchzH8WUBtAaoY8eOMnv2bHM/JyfHhJt7771Xxo0bV+z22dnZpmZIt4+Liyt2/czMTImIiJCMjAwJDw8vk/cAAADKV3mdv31aI5SVlSXbtm0zzVu5BapSxdzX2p6SOHHihJw+fVpq167t9fFTp06Zned5AwAA8HkQSk9PNzU6devWzbNc76emppboOR588EGpX79+njDladq0aSZBujetbQIAAPCLPkK/xfTp02XJkiWyfPly09Ham/Hjx5tqNPd28ODBCi8nAADwT1V9+eKRkZESHBwsaWlpeZbr/aioqCK3nTFjhglCH374obRt27bQ9UJDQ80NAADAr2qEQkJCpEOHDpKUlJS7TDtL6/0uXboUut2TTz4pjz32mKxZs0ZiYmIqqLQAACDQ+LRGSOnQ+fj4eBNoOnXqJLNmzZLjx4/L0KFDzeM6EqxBgwamr4964oknJCEhQRYvXmzmHnL7Ep177rnmBgAAUGmC0MCBA+XIkSMm3Gioad++vanpcTtQp6SkmJFkrhdffNGMNrv55pvzPI/OQ/TII49UePkBAEDl5fN5hCoa8wgBAFD5ZAbiPEIAAAC+RBACAADWIggBAABrEYQAAIC1CEIAAMBaBCEAAGAtghAAALAWQQgAAFiLIAQAAKxFEAIAANYiCAEAAGsRhAAAgLUIQgAAwFoEIQAAYC2CEAAAsBZBCAAAWIsgBAAArEUQAgAA1iIIAQAAaxGEAACAtQhCAADAWgQhAABgLYIQAACwFkEIAABYiyAEAACsRRACAADWIggBAABrEYQAAIC1CEIAAMBaBCEAAGAtghAAALAWQQgAAFiLIAQAAKxFEAIAANYiCAEAAGsRhAAAgLUIQgAAwFoEIQAAYC2CEAAAsBZBCAAAWIsgBAAArEUQAgAA1iIIAQAAaxGEAACAtQhCAADAWgQhAABgLYIQAACwFkEIAABYiyAEAACsRRACAADWIggBAABrEYQAAIC1CEIAAMBaBCEAAGAtghAAALAWQQgAAFiLIAQAAKxFEAIAANYiCAEAAGsRhAAAgLUIQgAAwFoEIQAAYC2CEAAAsJZfBKHExERp3LixhIWFSefOnWXLli1Frv/mm29Ky5YtzfqXXnqprF69usLKCgAAAofPg9DSpUtlzJgxMmnSJElOTpZ27dpJbGysHD582Ov6mzZtkkGDBsmwYcNk+/btMmDAAHPbuXNnhZcdAABUbkGO4zi+LIDWAHXs2FFmz55t7ufk5Eh0dLTce++9Mm7cuALrDxw4UI4fPy4rV67MXXbFFVdI+/btZc6cOcW+XmZmpkREREhGRoaEh4eX8bsBAADlobzO31XFh7KysmTbtm0yfvz43GVVqlSRXr16yebNm71uo8u1BsmT1iC98847Xtc/deqUubl0B7o7FAAAVA7uebus6298GoTS09MlOztb6tatm2e53t+9e7fXbVJTU72ur8u9mTZtmkyePLnAcq11AgAAlcuPP/5oaoYCIghVBK1t8qxBOnr0qDRq1EhSUlLKdEfi7NK9BtKDBw/STOkHOB7+g2PhPzgW/kNbdBo2bCi1a9cu0+f1aRCKjIyU4OBgSUtLy7Nc70dFRXndRpeXZv3Q0FBzy09DEB9q/6DHgWPhPzge/oNj4T84Fv5Du9CU6fOJD4WEhEiHDh0kKSkpd5l2ltb7Xbp08bqNLvdcX61du7bQ9QEAAPy2aUybreLj4yUmJkY6deoks2bNMqPChg4dah6Pi4uTBg0amL4+atSoUdKjRw95+umnpU+fPrJkyRLZunWrzJ0718fvBAAAVDY+D0I6HP7IkSOSkJBgOjzrMPg1a9bkdojWvjye1WBdu3aVxYsXy8SJE+Whhx6SZs2amRFjbdq0KdHraTOZzlnkrbkMFYtj4V84Hv6DY+E/OBaBfyx8Po8QAACAtTNLAwAA+ApBCAAAWIsgBAAArEUQAgAA1grIIJSYmCiNGzeWsLAwc1HXLVu2FLn+m2++KS1btjTrX3rppbJ69eoKK2ugK82xmDdvnnTv3l1q1aplbnrNueKOHcr3d8Ol01QEBQXJgAEDyr2MtijtsdBZ8UeOHCn16tUzo2aaN2/O3yofHQud5qVFixZSvXp1M+v06NGj5eTJkxVW3kC1YcMG6devn9SvX9/8vSnsGqKe1q9fL5dffrn5nWjatKksWrSo9C/sBJglS5Y4ISEhzoIFC5wvv/zSGT58uFOzZk0nLS3N6/qffvqpExwc7Dz55JPOV1995UycONGpVq2a88UXX1R42W0/FoMHD3YSExOd7du3O7t27XJuu+02JyIiwvnuu+8qvOyBqLTHw/X11187DRo0cLp37+7ccMMNFVbeQFbaY3Hq1CknJibG6d27t7Nx40ZzTNavX+/s2LGjwstu+7F47bXXnNDQUPO/Hof333/fqVevnjN69OgKL3ugWb16tTNhwgRn2bJlOprdWb58eZHrHzhwwKlRo4YzZswYc/5+/vnnzfl8zZo1pXrdgAtCnTp1ckaOHJl7Pzs726lfv74zbdo0r+vfcsstTp8+ffIs69y5s3PnnXeWe1kDXWmPRX5nzpxxzjvvPOeVV14px1La42yOhx6Drl27Oi+//LITHx9PEPLRsXjxxRediy++2MnKyqrAUtqhtMdC17366qvzLNMTcbdu3cq9rDaREgShBx54wLnkkkvyLBs4cKATGxtbqtcKqKaxrKws2bZtm2lScelkjHp/8+bNXrfR5Z7rq9jY2ELXR/kdi/xOnDghp0+fLvML7NnobI/Ho48+KnXq1JFhw4ZVUEkD39kcixUrVpjLCGnTmE42qxPITp06VbKzsyuw5IHnbI6FTuqr27jNZwcOHDBNlL17966wcqNsz98+n1m6LKWnp5s/DO6s1C69v3v3bq/b6GzW3tbX5ajYY5Hfgw8+aNqK83/QUTHHY+PGjTJ//nzZsWNHBZXSDmdzLPRk+9FHH8mtt95qTrr79u2Te+65x3xR0Jl2UXHHYvDgwWa7K6+8UltU5MyZM3LXXXeZKx2gYhV2/s7MzJRff/3V9OEqiYCqEULgmD59uumgu3z5ctOBERXr2LFjMmTIENOBPTIy0tfFsZ5ejFpr5vSainqhar000YQJE2TOnDm+Lpp1tHOu1sa98MILkpycLMuWLZNVq1bJY4895uui4SwFVI2Q/sEODg6WtLS0PMv1flRUlNdtdHlp1kf5HQvXjBkzTBD68MMPpW3btuVcUjuU9njs379fvvnmGzOCw/NkrKpWrSp79uyRJk2aVEDJA8/Z/G7oSLFq1aqZ7VytWrUy34i1eSckJKTcyx2IzuZYPPzww+ZLwh133GHu60hjvVD4iBEjTDj1vDYmyldh5+/w8PAS1wapgDpi+sdAvy0lJSXl+eOt97V93Rtd7rm+Wrt2baHro/yOhXryySfNNyu98G5MTEwFlTbwlfZ46HQSX3zxhWkWc2/9+/eXnj17mp91yDAq7nejW7dupjnMDaNq7969JiARgir2WGjfxfxhxw2oXLqzYpXZ+dsJwKGQOrRx0aJFZjjdiBEjzFDI1NRU8/iQIUOccePG5Rk+X7VqVWfGjBlmyPakSZMYPu+jYzF9+nQzjPWtt95yDh06lHs7duyYD9+FvccjP0aN+e5YpKSkmBGUf/nLX5w9e/Y4K1eudOrUqeNMmTLFh+/CzmOh5wg9Fq+//roZvv3BBx84TZo0MSOQ8dvo33qdPkVvGk9mzpxpfv7222/N43oc9HjkHz4/duxYc/7W6VcYPv//6VwCDRs2NCdVHRr52Wef5T7Wo0cP8wfd0xtvvOE0b97crK9D8VatWuWDUgem0hyLRo0amQ9//pv+4YFvfjc8EYR8eyw2bdpkpvbQk7YOpX/88cfN9Aao2GNx+vRp55FHHjHhJywszImOjnbuuece5+eff/ZR6QPHunXrvJ4D3P2v/+vxyL9N+/btzbHT34uFCxeW+nWD9J+yrawCAACoHAKqjxAAAEBpEIQAAIC1CEIAAMBaBCEAAGAtghAAALAWQQgAAFiLIAQAAKxFEAIAANYiCAEIWIsWLZKaNWv6uhgA/BhBCIDP3XbbbRIUFFTgphcaBYDyVLVcnx0ASuj3v/+9LFy4MM+yCy64wGflAWAHaoQA+IXQ0FCJiorKcwsODpZ3331XLr/8cgkLC5OLL75YJk+eLGfOnMnd7ujRo3LnnXdK3bp1zTpt2rSRlStX5nnu999/X1q1aiXnnnuuCVyHDh3Kfezzzz+Xa6+9ViIjIyUiIkJ69OghycnJFfreAfgOQQiA3/rkk08kLi5ORo0aJV999ZW89NJLpt/P448/bh7PycmR66+/Xj799FN59dVXzTrTp083Acp14sQJmTFjhvzjH/+QDRs2SEpKitx///25jx87dkzi4+Nl48aN8tlnn0mzZs2kd+/eZjmAwMfV5wH4RR8hDTJao+PSgPPzzz/LNddcI+PHj89drus98MAD8sMPP8gHH3xg1tu1a5c0b968wPNqaBo6dKjpa9SkSROz7IUXXpBHH31UUlNTvZZFw5V2sF68eLH07du3XN4vAP9BHyEAfqFnz57y4osv5t4/55xzpG3btqa2x60BUtnZ2XLy5ElT07Njxw658MILvYYgV40aNXJDkKpXr54cPnw4935aWppMnDhR1q9fb5br8+tza80RgMBHEALgFzT4NG3aNM+yX375xfQJuvHGGwusr7VH1atXL/Z5q1Wrlue+jkbzrAjXZrEff/xRnn32WWnUqJHpq9SlSxfJysr6Te8HQOVAEALgt7ST9J49ewoEJJfWGH333Xeyd+/eImuFiqI1Ttpcpv2C1MGDByU9Pf03lRtA5UEQAuC3EhISTD+dhg0bys033yxVqlSRf//737Jz506ZMmWKGeF11VVXyU033SQzZ840gWn37t2m1kdHh5WEdo7WjtQxMTGSmZkpY8eOLVFNE4DAwKgxAH4rNjbWDIXXTtEdO3aUK664Qp555hnThOV6++23zWODBg2S1q1bm47U2s+npObPn286ZWvt05AhQ+S+++6TOnXqlNM7AuBvGDUGAACsRY0QAACwFkEIAABYiyAEAACsRRACAADWIggBAABrEYQAAIC1CEIAAMBaBCEAAGAtghAAALAWQQgAAFiLIAQAAMRW/wdaNHdWdXSmTAAAAABJRU5ErkJggg==",
      "text/plain": [
       "<Figure size 640x480 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# ================================================================================================\n",
    "# ANALIZADOR ESPEC√çFICO DEL NOTEBOOK MIP QUILLOTA\n",
    "# ================================================================================================\n",
    "\n",
    "class MIPQuillotaNotebookAnalyzer:\n",
    "    def __init__(self, notebook_path):\n",
    "        self.notebook_path = notebook_path\n",
    "        self.notebook = None\n",
    "        self.errors_found = []\n",
    "        self.warnings = []\n",
    "        self.suggestions = []\n",
    "        \n",
    "    def load_and_analyze_notebook(self):\n",
    "        \"\"\"Carga y analiza el notebook espec√≠fico\"\"\"\n",
    "        print(\"üìì AN√ÅLISIS DEL NOTEBOOK MIP QUILLOTA:\")\n",
    "        print(\"-\"*40)\n",
    "        \n",
    "        if not os.path.exists(self.notebook_path):\n",
    "            error_msg = f\"Notebook no encontrado: {self.notebook_path}\"\n",
    "            print(f\"‚ùå {error_msg}\")\n",
    "            self.errors_found.append(error_msg)\n",
    "            return False\n",
    "        \n",
    "        try:\n",
    "            # Cargar notebook\n",
    "            with open(self.notebook_path, 'r', encoding='utf-8') as f:\n",
    "                self.notebook = nbformat.read(f, as_version=4)\n",
    "            \n",
    "            print(f\"‚úÖ Notebook cargado exitosamente\")\n",
    "            \n",
    "            # Realizar an√°lisis completo\n",
    "            self._analyze_notebook_structure()\n",
    "            self._analyze_imports_and_dependencies()\n",
    "            self._analyze_data_handling()\n",
    "            self._analyze_meteorological_code()\n",
    "            self._analyze_ml_models()\n",
    "            self._check_common_errors()\n",
    "            \n",
    "            return True\n",
    "            \n",
    "        except Exception as e:\n",
    "            error_msg = f\"Error cargando notebook: {str(e)}\"\n",
    "            print(f\"‚ùå {error_msg}\")\n",
    "            self.errors_found.append(error_msg)\n",
    "            return False\n",
    "    \n",
    "    def _analyze_notebook_structure(self):\n",
    "        \"\"\"Analiza la estructura general del notebook\"\"\"\n",
    "        print(f\"\\nüèóÔ∏è  ESTRUCTURA DEL NOTEBOOK:\")\n",
    "        print(\"-\"*30)\n",
    "        \n",
    "        total_cells = len(self.notebook.cells)\n",
    "        code_cells = sum(1 for cell in self.notebook.cells if cell.cell_type == 'code')\n",
    "        markdown_cells = sum(1 for cell in self.notebook.cells if cell.cell_type == 'markdown')\n",
    "        empty_code_cells = sum(1 for cell in self.notebook.cells \n",
    "                              if cell.cell_type == 'code' and not cell.source.strip())\n",
    "        \n",
    "        print(f\"   üìä Total celdas: {total_cells}\")\n",
    "        print(f\"   üêç Celdas c√≥digo: {code_cells}\")\n",
    "        print(f\"   üìù Celdas markdown: {markdown_cells}\")\n",
    "        print(f\"   ‚ö™ Celdas vac√≠as: {empty_code_cells}\")\n",
    "        \n",
    "        if empty_code_cells > 5:\n",
    "            self.warnings.append(f\"Muchas celdas de c√≥digo vac√≠as ({empty_code_cells})\")\n",
    "        \n",
    "        # Verificar kernel\n",
    "        if 'kernelspec' in self.notebook.metadata:\n",
    "            kernel_info = self.notebook.metadata['kernelspec']\n",
    "            print(f\"   üîß Kernel: {kernel_info.get('display_name', 'N/A')}\")\n",
    "            print(f\"   üêç Lenguaje: {kernel_info.get('language', 'N/A')}\")\n",
    "        else:\n",
    "            self.warnings.append(\"Sin informaci√≥n de kernel definida\")\n",
    "        \n",
    "        # Verificar outputs grandes\n",
    "        large_outputs = []\n",
    "        for i, cell in enumerate(self.notebook.cells):\n",
    "            if cell.cell_type == 'code' and hasattr(cell, 'outputs'):\n",
    "                for output in cell.outputs:\n",
    "                    if hasattr(output, 'data') and output.data:\n",
    "                        # Estimar tama√±o del output\n",
    "                        output_str = str(output.data)\n",
    "                        if len(output_str) > 10000:  # > 10KB\n",
    "                            large_outputs.append(f\"Celda {i+1}\")\n",
    "        \n",
    "        if large_outputs:\n",
    "            warning_msg = f\"Outputs grandes en: {', '.join(large_outputs)}\"\n",
    "            print(f\"   ‚ö†Ô∏è  {warning_msg}\")\n",
    "            self.warnings.append(warning_msg)\n",
    "    \n",
    "    def _analyze_imports_and_dependencies(self):\n",
    "        \"\"\"Analiza imports y dependencias\"\"\"\n",
    "        print(f\"\\nüì¶ IMPORTS Y DEPENDENCIAS:\")\n",
    "        print(\"-\"*30)\n",
    "        \n",
    "        all_imports = set()\n",
    "        missing_imports = []\n",
    "        \n",
    "        # Extraer todos los imports\n",
    "        for i, cell in enumerate(self.notebook.cells):\n",
    "            if cell.cell_type == 'code':\n",
    "                lines = cell.source.split('\\n')\n",
    "                for line in lines:\n",
    "                    line = line.strip()\n",
    "                    if line.startswith('import ') or line.startswith('from '):\n",
    "                        all_imports.add(line)\n",
    "        \n",
    "        print(f\"   üìã Total imports √∫nicos: {len(all_imports)}\")\n",
    "        \n",
    "        # Categorizar imports por tipo\n",
    "        standard_libs = []\n",
    "        data_science_libs = []\n",
    "        weather_libs = []\n",
    "        other_libs = []\n",
    "        \n",
    "        for imp in all_imports:\n",
    "            if any(lib in imp.lower() for lib in ['pandas', 'numpy', 'matplotlib', 'seaborn', 'sklearn']):\n",
    "                data_science_libs.append(imp)\n",
    "            elif any(lib in imp.lower() for lib in ['requests', 'json', 'datetime', 'os', 'sys']):\n",
    "                standard_libs.append(imp)\n",
    "            elif any(lib in imp.lower() for lib in ['meteostat', 'pyowm', 'weather', 'clima']):\n",
    "                weather_libs.append(imp)\n",
    "            else:\n",
    "                other_libs.append(imp)\n",
    "        \n",
    "        print(f\"   üêç Librer√≠as est√°ndar: {len(standard_libs)}\")\n",
    "        print(f\"   üìä Librer√≠as data science: {len(data_science_libs)}\")\n",
    "        print(f\"   üå§Ô∏è  Librer√≠as meteorol√≥gicas: {len(weather_libs)}\")\n",
    "        print(f\"   üìö Otras librer√≠as: {len(other_libs)}\")\n",
    "        \n",
    "        # Verificar librer√≠as cr√≠ticas para el proyecto\n",
    "        critical_libs = ['pandas', 'numpy', 'matplotlib', 'sklearn']\n",
    "        missing_critical = []\n",
    "        \n",
    "        for lib in critical_libs:\n",
    "            if not any(lib in imp.lower() for imp in all_imports):\n",
    "                missing_critical.append(lib)\n",
    "        \n",
    "        if missing_critical:\n",
    "            error_msg = f\"Librer√≠as cr√≠ticas faltantes: {missing_critical}\"\n",
    "            print(f\"   ‚ùå {error_msg}\")\n",
    "            self.errors_found.append(error_msg)\n",
    "        \n",
    "        # Mostrar algunos imports importantes\n",
    "        if data_science_libs:\n",
    "            print(f\"\\n   üìä Principales imports data science:\")\n",
    "            for imp in sorted(data_science_libs)[:5]:\n",
    "                print(f\"      ‚Ä¢ {imp}\")\n",
    "        \n",
    "        if weather_libs:\n",
    "            print(f\"\\n   üå§Ô∏è  Imports meteorol√≥gicos:\")\n",
    "            for imp in weather_libs:\n",
    "                print(f\"      ‚Ä¢ {imp}\")\n",
    "    \n",
    "    def _analyze_data_handling(self):\n",
    "        \"\"\"Analiza el manejo de datos\"\"\"\n",
    "        print(f\"\\nüìä MANEJO DE DATOS:\")\n",
    "        print(\"-\"*20)\n",
    "        \n",
    "        data_operations = {\n",
    "            'lectura_datos': ['pd.read_csv', 'pd.read_excel', 'pd.read_json', '.csv', '.xlsx'],\n",
    "            'limpieza_datos': ['.dropna()', '.fillna()', '.drop_duplicates()', '.isnull()'],\n",
    "            'transformacion': ['.groupby()', '.merge()', '.pivot()', '.melt()'],\n",
    "            'visualizacion': ['plt.', 'sns.', 'plotly', '.plot()', 'matplotlib']\n",
    "        }\n",
    "        \n",
    "        operations_found = {key: [] for key in data_operations.keys()}\n",
    "        \n",
    "        # Buscar operaciones en el c√≥digo\n",
    "        for i, cell in enumerate(self.notebook.cells):\n",
    "            if cell.cell_type == 'code':\n",
    "                cell_source = cell.source.lower()\n",
    "                \n",
    "                for operation_type, patterns in data_operations.items():\n",
    "                    for pattern in patterns:\n",
    "                        if pattern.lower() in cell_source:\n",
    "                            operations_found[operation_type].append(f\"Celda {i+1}\")\n",
    "                            break\n",
    "        \n",
    "        # Reportar operaciones encontradas\n",
    "        for operation_type, cells in operations_found.items():\n",
    "            count = len(set(cells))  # Celdas √∫nicas\n",
    "            if count > 0:\n",
    "                print(f\"   ‚úÖ {operation_type.replace('_', ' ').title()}: {count} celdas\")\n",
    "            else:\n",
    "                print(f\"   ‚ùå {operation_type.replace('_', ' ').title()}: No encontrado\")\n",
    "                \n",
    "                if operation_type == 'lectura_datos':\n",
    "                    self.warnings.append(\"No se detect√≥ carga de datos\")\n",
    "                elif operation_type == 'limpieza_datos':\n",
    "                    self.warnings.append(\"No se detect√≥ limpieza de datos\")\n",
    "    \n",
    "    def _analyze_meteorological_code(self):\n",
    "        \"\"\"Analiza c√≥digo espec√≠fico meteorol√≥gico\"\"\"\n",
    "        print(f\"\\nüå§Ô∏è  AN√ÅLISIS METEOROL√ìGICO:\")\n",
    "        print(\"-\"*25)\n",
    "        \n",
    "        meteo_keywords = {\n",
    "            'variables_meteo': ['temperatura', 'humedad', 'precipitacion', 'viento', 'presion'],\n",
    "            'unidades': ['celsius', '¬∞c', 'fahrenheit', 'mm', 'km/h', 'hpa', 'mb'],\n",
    "            'estaciones': ['primavera', 'verano', 'oto√±o', 'invierno'],\n",
    "            'agricola': ['cultivo', 'siembra', 'cosecha', 'riego', 'mip', 'quillota']\n",
    "        }\n",
    "        \n",
    "        keywords_found = {key: [] for key in meteo_keywords.keys()}\n",
    "        \n",
    "        # Buscar palabras clave meteorol√≥gicas\n",
    "        for i, cell in enumerate(self.notebook.cells):\n",
    "            if cell.cell_type in ['code', 'markdown']:\n",
    "                cell_source = cell.source.lower()\n",
    "                \n",
    "                for category, keywords in meteo_keywords.items():\n",
    "                    for keyword in keywords:\n",
    "                        if keyword in cell_source:\n",
    "                            keywords_found[category].append(keyword)\n",
    "        \n",
    "        # Reportar hallazgos\n",
    "        for category, keywords in keywords_found.items():\n",
    "            unique_keywords = list(set(keywords))\n",
    "            if unique_keywords:\n",
    "                print(f\"   ‚úÖ {category.replace('_', ' ').title()}: {len(unique_keywords)} t√©rminos\")\n",
    "                print(f\"      {', '.join(unique_keywords[:5])}\")  # Mostrar m√°ximo 5\n",
    "            else:\n",
    "                print(f\"   ‚ö†Ô∏è  {category.replace('_', ' ').title()}: No encontrado\")\n",
    "        \n",
    "        # Verificar rangos t√≠picos meteorol√≥gicos\n",
    "        range_checks = [\n",
    "            'temperatura.*(-?\\d+\\.?\\d*)',\n",
    "            'humedad.*(\\d+\\.?\\d*).*%',\n",
    "            'precipitacion.*(\\d+\\.?\\d*).*mm'\n",
    "        ]\n",
    "        \n",
    "        print(f\"\\n   üîç Verificaci√≥n de rangos meteorol√≥gicos:\")\n",
    "        import re\n",
    "        \n",
    "        for i, cell in enumerate(self.notebook.cells):\n",
    "            if cell.cell_type == 'code':\n",
    "                for pattern in range_checks:\n",
    "                    matches = re.findall(pattern, cell.source, re.IGNORECASE)\n",
    "                    if matches:\n",
    "                        var_type = pattern.split('.*')[0]\n",
    "                        print(f\"      ‚Ä¢ {var_type.title()} detectada en celda {i+1}\")\n",
    "    \n",
    "    def _analyze_ml_models(self):\n",
    "        \"\"\"Analiza modelos de machine learning\"\"\"\n",
    "        print(f\"\\nü§ñ MODELOS DE MACHINE LEARNING:\")\n",
    "        print(\"-\"*32)\n",
    "        \n",
    "        ml_patterns = {\n",
    "            'sklearn_models': ['RandomForest', 'LinearRegression', 'SVM', 'KMeans', 'DecisionTree'],\n",
    "            'model_evaluation': ['train_test_split', 'cross_val_score', 'accuracy_score', 'mean_squared_error'],\n",
    "            'preprocessing': ['StandardScaler', 'MinMaxScaler', 'LabelEncoder', 'OneHotEncoder'],\n",
    "            'deep_learning': ['tensorflow', 'keras', 'pytorch', 'neural', 'deep']\n",
    "        }\n",
    "        \n",
    "        ml_found = {key: [] for key in ml_patterns.keys()}\n",
    "        \n",
    "        # Buscar patrones de ML\n",
    "        for i, cell in enumerate(self.notebook.cells):\n",
    "            if cell.cell_type == 'code':\n",
    "                cell_source = cell.source\n",
    "                \n",
    "                for category, patterns in ml_patterns.items():\n",
    "                    for pattern in patterns:\n",
    "                        if pattern in cell_source:\n",
    "                            ml_found[category].append(f\"Celda {i+1}\")\n",
    "                            break\n",
    "        \n",
    "        # Reportar modelos encontrados\n",
    "        total_ml_indicators = sum(len(cells) for cells in ml_found.values())\n",
    "        \n",
    "        if total_ml_indicators == 0:\n",
    "            print(f\"   ‚ö†Ô∏è  No se detectaron modelos de ML\")\n",
    "            self.warnings.append(\"No se detectaron modelos de machine learning\")\n",
    "        else:\n",
    "            print(f\"   ‚úÖ Indicadores de ML encontrados: {total_ml_indicators}\")\n",
    "            \n",
    "            for category, cells in ml_found.items():\n",
    "                if cells:\n",
    "                    unique_cells = list(set(cells))\n",
    "                    print(f\"      ‚Ä¢ {category.replace('_', ' ').title()}: {len(unique_cells)} celdas\")\n",
    "    \n",
    "    def _check_common_errors(self):\n",
    "        \"\"\"Verifica errores comunes en notebooks\"\"\"\n",
    "        print(f\"\\nüîç VERIFICACI√ìN DE ERRORES COMUNES:\")\n",
    "        print(\"-\"*35)\n",
    "        \n",
    "        common_issues = []\n",
    "        \n",
    "        for i, cell in enumerate(self.notebook.cells):\n",
    "            if cell.cell_type == 'code':\n",
    "                source = cell.source\n",
    "                \n",
    "                # Verificar errores comunes\n",
    "                if 'print(' in source and len(source.split('\\n')) == 1:\n",
    "                    common_issues.append(f\"Celda {i+1}: Print statement simple (posible debug)\")\n",
    "                \n",
    "                if source.count('import') > 5:\n",
    "                    common_issues.append(f\"Celda {i+1}: Muchos imports en una celda\")\n",
    "                \n",
    "                if len(source) > 2000:  # Celda muy larga\n",
    "                    common_issues.append(f\"Celda {i+1}: Celda muy larga ({len(source)} caracteres)\")\n",
    "                \n",
    "                if '#TODO' in source or '#FIXME' in source:\n",
    "                    common_issues.append(f\"Celda {i+1}: Comentarios TODO/FIXME\")\n",
    "                \n",
    "                # Verificar rutas hardcodeadas\n",
    "                if 'C:\\\\' in source or '/Users/' in source:\n",
    "                    common_issues.append(f\"Celda {i+1}: Ruta hardcodeada detectada\")\n",
    "        \n",
    "        if common_issues:\n",
    "            print(f\"   ‚ö†Ô∏è  Problemas encontrados: {len(common_issues)}\")\n",
    "            for issue in common_issues[:10]:  # Mostrar m√°ximo 10\n",
    "                print(f\"      ‚Ä¢ {issue}\")\n",
    "            self.warnings.extend(common_issues)\n",
    "        else:\n",
    "            print(f\"   ‚úÖ No se encontraron problemas comunes\")\n",
    "    \n",
    "    def generate_report(self):\n",
    "        \"\"\"Genera reporte final de an√°lisis\"\"\"\n",
    "        print(f\"\\nüìã REPORTE FINAL DEL AN√ÅLISIS:\")\n",
    "        print(\"=\"*35)\n",
    "        \n",
    "        # Contar tipos de problemas\n",
    "        critical_errors = len(self.errors_found)\n",
    "        warnings_count = len(self.warnings)\n",
    "        \n",
    "        print(f\"üìä Resumen:\")\n",
    "        print(f\"   ‚ùå Errores cr√≠ticos: {critical_errors}\")\n",
    "        print(f\"   ‚ö†Ô∏è  Advertencias: {warnings_count}\")\n",
    "        \n",
    "        # Mostrar errores cr√≠ticos\n",
    "        if self.errors_found:\n",
    "            print(f\"\\n‚ùå ERRORES CR√çTICOS QUE REQUIEREN ATENCI√ìN:\")\n",
    "            for i, error in enumerate(self.errors_found, 1):\n",
    "                print(f\"   {i}. {error}\")\n",
    "        \n",
    "        # Mostrar advertencias m√°s importantes\n",
    "        if self.warnings:\n",
    "            print(f\"\\n‚ö†Ô∏è  ADVERTENCIAS PRINCIPALES:\")\n",
    "            for i, warning in enumerate(self.warnings[:10], 1):  # Top 10\n",
    "                print(f\"   {i}. {warning}\")\n",
    "        \n",
    "        # Sugerencias de mejora\n",
    "        print(f\"\\nüí° SUGERENCIAS DE MEJORA:\")\n",
    "        if not self.errors_found and not self.warnings:\n",
    "            print(\"   üéâ ¬°Excelente! No se encontraron problemas significativos\")\n",
    "        else:\n",
    "            print(\"   1. Revisar y corregir errores cr√≠ticos primero\")\n",
    "            print(\"   2. Agregar documentaci√≥n en celdas markdown\")\n",
    "            print(\"   3. Organizar imports en una sola celda al inicio\")\n",
    "            print(\"   4. Eliminar celdas de c√≥digo vac√≠as\")\n",
    "            print(\"   5. Validar rangos de datos meteorol√≥gicos\")\n",
    "            print(\"   6. Agregar manejo de errores (try-except)\")\n",
    "            print(\"   7. Usar rutas relativas en lugar de absolutas\")\n",
    "            print(\"   8. Limpiar outputs grandes innecesarios\")\n",
    "            print(\"   9. Agregar validaci√≥n de datos de entrada\")\n",
    "            print(\"   10. Documentar par√°metros de modelos ML\")\n",
    "        \n",
    "        return {\n",
    "            'errors': self.errors_found,\n",
    "            'warnings': self.warnings,\n",
    "            'critical_count': critical_errors,\n",
    "            'warning_count': warnings_count\n",
    "        }\n",
    "\n",
    "# Crear analizador y ejecutar an√°lisis completo\n",
    "notebook_path = os.path.join(PROJECT_PATH, NOTEBOOK_NAME)\n",
    "analyzer = MIPQuillotaNotebookAnalyzer(notebook_path)\n",
    "\n",
    "print(\"üöÄ INICIANDO AN√ÅLISIS COMPLETO DEL NOTEBOOK...\")\n",
    "success = analyzer.load_and_analyze_notebook()\n",
    "\n",
    "if success:\n",
    "    print(\"\\n\" + \"=\"*65)\n",
    "    report = analyzer.generate_report()\n",
    "    print(\"=\"*65)\n",
    "else:\n",
    "    print(\"‚ùå No se pudo completar el an√°lisis del notebook\")\n",
    "# Auto-fix: T√≠tulo agregado\n",
    "plt.title(\"An√°lisis Meteorol√≥gico - Quillota\")\n",
    "plt.xlabel(\"Fecha\")\n",
    "plt.ylabel(\"Valor\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "701fd292-edcc-45fb-bdee-f90cbf562cdd",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "‚úÖ Clase PythonErrorDetective definida correctamente\n",
      "üöÄ Ahora puedes crear una instancia y analizar tu notebook\n"
     ]
    }
   ],
   "source": [
    "# ================================================================================================\n",
    "# PASO 1: DEFINIR LA CLASE DETECTIVE DE ERRORES\n",
    "# ================================================================================================\n",
    "\n",
    "import ast\n",
    "import re\n",
    "import sys\n",
    "import traceback\n",
    "from io import StringIO\n",
    "import os\n",
    "import nbformat\n",
    "from datetime import datetime\n",
    "\n",
    "class PythonErrorDetective:\n",
    "    def __init__(self, notebook_path):\n",
    "        self.notebook_path = notebook_path\n",
    "        self.notebook = None\n",
    "        self.errors_found = []\n",
    "        self.warnings_found = []\n",
    "        self.syntax_errors = []\n",
    "        self.problematic_cells = []\n",
    "        \n",
    "    def load_and_analyze_notebook(self):\n",
    "        \"\"\"Carga el notebook y analiza cada celda\"\"\"\n",
    "        print(\"üïµÔ∏è DETECTIVE DE ERRORES EN ACCI√ìN:\")\n",
    "        print(\"=\" * 35)\n",
    "        \n",
    "        try:\n",
    "            with open(self.notebook_path, 'r', encoding='utf-8') as f:\n",
    "                self.notebook = nbformat.read(f, as_version=4)\n",
    "            \n",
    "            print(f\"üìì Notebook cargado: {len(self.notebook.cells)} celdas\")\n",
    "            print(f\"üîç Iniciando an√°lisis detallado...\")\n",
    "            \n",
    "            # Analizar cada celda\n",
    "            for i, cell in enumerate(self.notebook.cells):\n",
    "                if cell.cell_type == 'code':\n",
    "                    self._analyze_cell_deep(i, cell)\n",
    "            \n",
    "            # Mostrar resumen de problemas\n",
    "            self._show_error_summary()\n",
    "            \n",
    "            return True\n",
    "            \n",
    "        except Exception as e:\n",
    "            print(f\"‚ùå Error cargando notebook: {str(e)}\")\n",
    "            return False\n",
    "    \n",
    "    def _analyze_cell_deep(self, cell_index, cell):\n",
    "        \"\"\"An√°lisis profundo de una celda espec√≠fica\"\"\"\n",
    "        cell_num = cell_index + 1\n",
    "        source_code = cell.source\n",
    "        \n",
    "        if not source_code.strip():\n",
    "            return\n",
    "        \n",
    "        print(f\"\\nüî¨ ANALIZANDO CELDA {cell_num}:\")\n",
    "        print(f\"   üìè Longitud: {len(source_code)} caracteres\")\n",
    "        print(f\"   üìÑ L√≠neas: {len(source_code.split(chr(10)))}\")\n",
    "        \n",
    "        cell_problems = {\n",
    "            'cell_number': cell_num,\n",
    "            'syntax_errors': [],\n",
    "            'runtime_errors': [],\n",
    "            'warnings': [],\n",
    "            'code_smells': [],\n",
    "            'regex_issues': [],\n",
    "            'string_issues': [],\n",
    "            'source_length': len(source_code),\n",
    "            'line_count': len(source_code.split('\\n'))\n",
    "        }\n",
    "        \n",
    "        # 1. AN√ÅLISIS DE SINTAXIS\n",
    "        syntax_ok = self._check_syntax_errors(source_code, cell_problems)\n",
    "        \n",
    "        # 2. AN√ÅLISIS DE STRINGS (solo si hay problemas de sintaxis)\n",
    "        if not syntax_ok:\n",
    "            self._check_string_issues(source_code, cell_problems)\n",
    "        \n",
    "        # 3. AN√ÅLISIS DE PATRONES PROBLEM√ÅTICOS\n",
    "        self._check_code_patterns(source_code, cell_problems)\n",
    "        \n",
    "        # 4. AN√ÅLISIS DE IMPORTS\n",
    "        self._check_import_issues(source_code, cell_problems)\n",
    "        \n",
    "        # Guardar problemas encontrados si los hay\n",
    "        if any(cell_problems[key] for key in ['syntax_errors', 'runtime_errors', 'warnings', 'code_smells', 'regex_issues', 'string_issues']):\n",
    "            self.problematic_cells.append(cell_problems)\n",
    "            \n",
    "        # Mostrar problemas de esta celda\n",
    "        self._show_cell_problems(cell_problems)\n",
    "    \n",
    "    def _check_syntax_errors(self, code, problems):\n",
    "        \"\"\"Detecta errores de sintaxis espec√≠ficos\"\"\"\n",
    "        try:\n",
    "            # Intentar compilar el c√≥digo\n",
    "            compile(code, f'<cell_{problems[\"cell_number\"]}>', 'exec')\n",
    "            print(\"   ‚úÖ Sintaxis v√°lida\")\n",
    "            return True\n",
    "            \n",
    "        except SyntaxError as e:\n",
    "            error_info = {\n",
    "                'type': 'SyntaxError',\n",
    "                'message': str(e.msg) if e.msg else 'Error de sintaxis desconocido',\n",
    "                'line': e.lineno if e.lineno else 'N/A',\n",
    "                'column': e.offset if e.offset else 'N/A',\n",
    "                'text': e.text.strip() if e.text else 'N/A'\n",
    "            }\n",
    "            \n",
    "            problems['syntax_errors'].append(error_info)\n",
    "            print(f\"   ‚ùå Error de sintaxis en l√≠nea {e.lineno}: {e.msg}\")\n",
    "            \n",
    "            # An√°lisis espec√≠fico del error\n",
    "            if e.msg and 'unterminated string literal' in str(e.msg):\n",
    "                print(\"   üîç PROBLEMA DETECTADO: Cadena de texto no cerrada\")\n",
    "                self._analyze_string_termination_error(code, e, problems)\n",
    "            \n",
    "            elif e.msg and 'invalid character' in str(e.msg):\n",
    "                print(\"   üîç PROBLEMA DETECTADO: Caracter inv√°lido\")\n",
    "                self._analyze_invalid_character_error(code, e, problems)\n",
    "            \n",
    "            elif e.msg and 'unexpected EOF' in str(e.msg):\n",
    "                print(\"   üîç PROBLEMA DETECTADO: Final de archivo inesperado\")\n",
    "            \n",
    "            return False\n",
    "            \n",
    "        except Exception as e:\n",
    "            problems['runtime_errors'].append({\n",
    "                'type': type(e).__name__,\n",
    "                'message': str(e)\n",
    "            })\n",
    "            print(f\"   ‚ùå Error de compilaci√≥n: {str(e)}\")\n",
    "            return False\n",
    "    \n",
    "    def _analyze_string_termination_error(self, code, syntax_error, problems):\n",
    "        \"\"\"Analiza errores de cadenas no terminadas\"\"\"\n",
    "        lines = code.split('\\n')\n",
    "        problem_line = syntax_error.lineno - 1 if syntax_error.lineno else 0\n",
    "        \n",
    "        if 0 <= problem_line < len(lines):\n",
    "            line = lines[problem_line]\n",
    "            \n",
    "            print(f\"      üìù L√≠nea problem√°tica: {line.strip()[:100]}...\")\n",
    "            \n",
    "            # Contar comillas\n",
    "            single_quotes = line.count(\"'\")\n",
    "            double_quotes = line.count('\"')\n",
    "            \n",
    "            print(f\"      üìä Comillas simples: {single_quotes}, dobles: {double_quotes}\")\n",
    "            \n",
    "            # Detectar patrones espec√≠ficos\n",
    "            if r'\\\\' in line and ('r\"' in line or \"r'\" in line):\n",
    "                print(\"      üéØ CAUSA PROBABLE: Problema con raw string y barras invertidas\")\n",
    "                problems['string_issues'].append({\n",
    "                    'issue': 'raw_string_backslash',\n",
    "                    'line': problem_line + 1,\n",
    "                    'suggestion': 'Revisar escapado de barras invertidas en raw string',\n",
    "                    'line_content': line.strip()\n",
    "                })\n",
    "            \n",
    "            elif single_quotes % 2 != 0:\n",
    "                print(\"      üéØ CAUSA PROBABLE: Comilla simple sin cerrar\")\n",
    "                problems['string_issues'].append({\n",
    "                    'issue': 'unclosed_single_quote',\n",
    "                    'line': problem_line + 1,\n",
    "                    'suggestion': 'Agregar comilla simple de cierre',\n",
    "                    'line_content': line.strip()\n",
    "                })\n",
    "            \n",
    "            elif double_quotes % 2 != 0:\n",
    "                print(\"      üéØ CAUSA PROBABLE: Comilla doble sin cerrar\")\n",
    "                problems['string_issues'].append({\n",
    "                    'issue': 'unclosed_double_quote',\n",
    "                    'line': problem_line + 1,\n",
    "                    'suggestion': 'Agregar comilla doble de cierre',\n",
    "                    'line_content': line.strip()\n",
    "                })\n",
    "    \n",
    "    def _analyze_invalid_character_error(self, code, syntax_error, problems):\n",
    "        \"\"\"Analiza errores de caracteres inv√°lidos\"\"\"\n",
    "        lines = code.split('\\n')\n",
    "        problem_line = syntax_error.lineno - 1 if syntax_error.lineno else 0\n",
    "        \n",
    "        if 0 <= problem_line < len(lines):\n",
    "            line = lines[problem_line]\n",
    "            print(f\"      üìù L√≠nea con caracter inv√°lido: {line.strip()[:100]}...\")\n",
    "            \n",
    "            # Buscar caracteres no ASCII\n",
    "            non_ascii_chars = [char for char in line if ord(char) > 127]\n",
    "            if non_ascii_chars:\n",
    "                print(f\"      üîç Caracteres no-ASCII encontrados: {non_ascii_chars}\")\n",
    "                problems['string_issues'].append({\n",
    "                    'issue': 'non_ascii_character',\n",
    "                    'line': problem_line + 1,\n",
    "                    'suggestion': 'Eliminar o reemplazar caracteres no-ASCII',\n",
    "                    'characters': non_ascii_chars,\n",
    "                    'line_content': line.strip()\n",
    "                })\n",
    "    \n",
    "    def _check_string_issues(self, code, problems):\n",
    "        \"\"\"Detecta problemas espec√≠ficos con strings\"\"\"\n",
    "        lines = code.split('\\n')\n",
    "        \n",
    "        for i, line in enumerate(lines):\n",
    "            line_num = i + 1\n",
    "            \n",
    "            # Detectar raw strings con problemas\n",
    "            if 'r\"' in line or \"r'\" in line:\n",
    "                if line.rstrip().endswith('\\\\'):\n",
    "                    problems['string_issues'].append({\n",
    "                        'issue': 'raw_string_trailing_backslash',\n",
    "                        'line': line_num,\n",
    "                        'content': line.strip(),\n",
    "                        'suggestion': 'Raw string no puede terminar con barra invertida'\n",
    "                    })\n",
    "                    print(f\"   ‚ö†Ô∏è  L√≠nea {line_num}: Raw string termina con \\\\\")\n",
    "            \n",
    "            # Detectar l√≠neas muy largas con strings\n",
    "            if len(line) > 200 and ('\"' in line or \"'\" in line):\n",
    "                print(f\"   ‚ö†Ô∏è  L√≠nea {line_num}: L√≠nea muy larga con strings ({len(line)} chars)\")\n",
    "    \n",
    "    def _check_code_patterns(self, code, problems):\n",
    "        \"\"\"Detecta patrones de c√≥digo problem√°ticos\"\"\"\n",
    "        \n",
    "        # Buscar patrones problem√°ticos simples\n",
    "        if 'r\"' in code and code.count('\"') % 2 != 0:\n",
    "            problems['code_smells'].append({\n",
    "                'pattern': 'unmatched_quotes_with_raw_string',\n",
    "                'description': 'Raw string con comillas desbalanceadas',\n",
    "                'matches': 1\n",
    "            })\n",
    "            print(\"   üîç Patr√≥n problem√°tico: Raw string con comillas desbalanceadas\")\n",
    "        \n",
    "        if '\\\\\\\\\\\\\\\\' in code:\n",
    "            problems['code_smells'].append({\n",
    "                'pattern': 'excessive_backslashes',\n",
    "                'description': 'Exceso de barras invertidas (posible sobre-escapado)',\n",
    "                'matches': code.count('\\\\\\\\\\\\\\\\')\n",
    "            })\n",
    "            print(\"   üîç Patr√≥n problem√°tico: Exceso de barras invertidas\")\n",
    "    \n",
    "    def _check_import_issues(self, code, problems):\n",
    "        \"\"\"Detecta problemas con imports\"\"\"\n",
    "        lines = code.split('\\n')\n",
    "        import_count = 0\n",
    "        \n",
    "        for line in lines:\n",
    "            if line.strip().startswith(('import ', 'from ')):\n",
    "                import_count += 1\n",
    "        \n",
    "        if import_count > 20:\n",
    "            problems['warnings'].append({\n",
    "                'type': 'too_many_imports',\n",
    "                'count': import_count,\n",
    "                'suggestion': 'Considerar organizar imports en celdas separadas'\n",
    "            })\n",
    "            print(f\"   ‚ö†Ô∏è  Muchos imports en esta celda: {import_count}\")\n",
    "    \n",
    "    def _show_cell_problems(self, problems):\n",
    "        \"\"\"Muestra los problemas encontrados en una celda\"\"\"\n",
    "        total_problems = sum(len(problems[key]) for key in \n",
    "                           ['syntax_errors', 'string_issues', 'code_smells', 'warnings'])\n",
    "        \n",
    "        if total_problems == 0:\n",
    "            print(\"   ‚úÖ No hay problemas detectados\")\n",
    "        else:\n",
    "            print(f\"   üìä Total de problemas en esta celda: {total_problems}\")\n",
    "    \n",
    "    def _show_error_summary(self):\n",
    "        \"\"\"Muestra resumen completo de errores\"\"\"\n",
    "        print(f\"\\nüìã RESUMEN COMPLETO DE PROBLEMAS DETECTADOS:\")\n",
    "        print(\"=\" * 50)\n",
    "        \n",
    "        if not self.problematic_cells:\n",
    "            print(\"üéâ ¬°No se encontraron problemas en el notebook!\")\n",
    "            return\n",
    "        \n",
    "        # Contar tipos de problemas\n",
    "        syntax_errors = sum(len(cell['syntax_errors']) for cell in self.problematic_cells)\n",
    "        string_issues = sum(len(cell['string_issues']) for cell in self.problematic_cells)\n",
    "        code_smells = sum(len(cell['code_smells']) for cell in self.problematic_cells)\n",
    "        warnings = sum(len(cell['warnings']) for cell in self.problematic_cells)\n",
    "        \n",
    "        print(f\"üìä ESTAD√çSTICAS:\")\n",
    "        print(f\"   ‚Ä¢ Celdas con problemas: {len(self.problematic_cells)}\")\n",
    "        print(f\"   ‚Ä¢ Errores de sintaxis: {syntax_errors}\")\n",
    "        print(f\"   ‚Ä¢ Problemas con strings: {string_issues}\")\n",
    "        print(f\"   ‚Ä¢ Code smells: {code_smells}\")\n",
    "        print(f\"   ‚Ä¢ Advertencias: {warnings}\")\n",
    "        \n",
    "        # Mostrar celdas m√°s problem√°ticas\n",
    "        print(f\"\\nüéØ CELDAS M√ÅS PROBLEM√ÅTICAS:\")\n",
    "        sorted_cells = sorted(self.problematic_cells, \n",
    "                            key=lambda x: len(x['syntax_errors']) + len(x['string_issues']), \n",
    "                            reverse=True)\n",
    "        \n",
    "        for i, cell_problems in enumerate(sorted_cells[:5], 1):  # Top 5\n",
    "            cell_num = cell_problems['cell_number']\n",
    "            syntax_count = len(cell_problems['syntax_errors'])\n",
    "            string_count = len(cell_problems['string_issues'])\n",
    "            total = syntax_count + string_count\n",
    "            \n",
    "            if total > 0:\n",
    "                print(f\"   {i}. Celda {cell_num}: {total} problemas cr√≠ticos\")\n",
    "                if syntax_count > 0:\n",
    "                    print(f\"      ‚Ä¢ {syntax_count} errores de sintaxis\")\n",
    "                if string_count > 0:\n",
    "                    print(f\"      ‚Ä¢ {string_count} problemas con strings\")\n",
    "        \n",
    "        return self.problematic_cells\n",
    "\n",
    "print(\"‚úÖ Clase PythonErrorDetective definida correctamente\")\n",
    "print(\"üöÄ Ahora puedes crear una instancia y analizar tu notebook\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "09040b1a-04e6-4111-a218-77014d798012",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "üïµÔ∏è DETECTIVE DE ERRORES - MIP QUILLOTA\n",
      "=============================================\n",
      "üìÅ Analizando: Sistema de Pron√≥stico Meteorol√≥gico y Gesti√≥n Agr√≠cola MIP Quillota.ipynb\n",
      "üïµÔ∏è DETECTIVE DE ERRORES EN ACCI√ìN:\n",
      "===================================\n",
      "üìì Notebook cargado: 32 celdas\n",
      "üîç Iniciando an√°lisis detallado...\n",
      "\n",
      "üî¨ ANALIZANDO CELDA 1:\n",
      "   üìè Longitud: 1251 caracteres\n",
      "   üìÑ L√≠neas: 32\n",
      "   ‚úÖ Sintaxis v√°lida\n",
      "   ‚úÖ No hay problemas detectados\n",
      "\n",
      "üî¨ ANALIZANDO CELDA 2:\n",
      "   üìè Longitud: 3601 caracteres\n",
      "   üìÑ L√≠neas: 114\n",
      "   ‚úÖ Sintaxis v√°lida\n",
      "   ‚ö†Ô∏è  Muchos imports en esta celda: 35\n",
      "   üìä Total de problemas en esta celda: 1\n",
      "\n",
      "üî¨ ANALIZANDO CELDA 3:\n",
      "   üìè Longitud: 6304 caracteres\n",
      "   üìÑ L√≠neas: 145\n",
      "   ‚úÖ Sintaxis v√°lida\n",
      "   ‚úÖ No hay problemas detectados\n",
      "\n",
      "üî¨ ANALIZANDO CELDA 4:\n",
      "   üìè Longitud: 41219 caracteres\n",
      "   üìÑ L√≠neas: 920\n",
      "   ‚úÖ Sintaxis v√°lida\n",
      "   ‚úÖ No hay problemas detectados\n",
      "\n",
      "üî¨ ANALIZANDO CELDA 5:\n",
      "   üìè Longitud: 44654 caracteres\n",
      "   üìÑ L√≠neas: 1064\n",
      "   ‚úÖ Sintaxis v√°lida\n",
      "   ‚úÖ No hay problemas detectados\n",
      "\n",
      "üî¨ ANALIZANDO CELDA 6:\n",
      "   üìè Longitud: 46731 caracteres\n",
      "   üìÑ L√≠neas: 960\n",
      "   ‚úÖ Sintaxis v√°lida\n",
      "   ‚úÖ No hay problemas detectados\n",
      "\n",
      "üî¨ ANALIZANDO CELDA 7:\n",
      "   üìè Longitud: 49271 caracteres\n",
      "   üìÑ L√≠neas: 1015\n",
      "   ‚úÖ Sintaxis v√°lida\n",
      "   ‚úÖ No hay problemas detectados\n",
      "\n",
      "üî¨ ANALIZANDO CELDA 8:\n",
      "   üìè Longitud: 13581 caracteres\n",
      "   üìÑ L√≠neas: 306\n",
      "   ‚úÖ Sintaxis v√°lida\n",
      "   ‚úÖ No hay problemas detectados\n",
      "\n",
      "üî¨ ANALIZANDO CELDA 9:\n",
      "   üìè Longitud: 2323 caracteres\n",
      "   üìÑ L√≠neas: 60\n",
      "   ‚úÖ Sintaxis v√°lida\n",
      "   ‚úÖ No hay problemas detectados\n",
      "\n",
      "üî¨ ANALIZANDO CELDA 10:\n",
      "   üìè Longitud: 1093 caracteres\n",
      "   üìÑ L√≠neas: 30\n",
      "   ‚úÖ Sintaxis v√°lida\n",
      "   ‚úÖ No hay problemas detectados\n",
      "\n",
      "üî¨ ANALIZANDO CELDA 11:\n",
      "   üìè Longitud: 48912 caracteres\n",
      "   üìÑ L√≠neas: 1079\n",
      "   ‚úÖ Sintaxis v√°lida\n",
      "   ‚úÖ No hay problemas detectados\n",
      "\n",
      "üî¨ ANALIZANDO CELDA 12:\n",
      "   üìè Longitud: 3505 caracteres\n",
      "   üìÑ L√≠neas: 73\n",
      "   ‚úÖ Sintaxis v√°lida\n",
      "   ‚úÖ No hay problemas detectados\n",
      "\n",
      "üî¨ ANALIZANDO CELDA 13:\n",
      "   üìè Longitud: 1708 caracteres\n",
      "   üìÑ L√≠neas: 34\n",
      "   ‚úÖ Sintaxis v√°lida\n",
      "   ‚úÖ No hay problemas detectados\n",
      "\n",
      "üî¨ ANALIZANDO CELDA 14:\n",
      "   üìè Longitud: 1196 caracteres\n",
      "   üìÑ L√≠neas: 36\n",
      "   ‚úÖ Sintaxis v√°lida\n",
      "   ‚úÖ No hay problemas detectados\n",
      "\n",
      "üî¨ ANALIZANDO CELDA 15:\n",
      "   üìè Longitud: 8392 caracteres\n",
      "   üìÑ L√≠neas: 185\n",
      "   ‚úÖ Sintaxis v√°lida\n",
      "   ‚úÖ No hay problemas detectados\n",
      "\n",
      "üî¨ ANALIZANDO CELDA 16:\n",
      "   üìè Longitud: 81525 caracteres\n",
      "   üìÑ L√≠neas: 1567\n",
      "   ‚úÖ Sintaxis v√°lida\n",
      "   ‚úÖ No hay problemas detectados\n",
      "\n",
      "üî¨ ANALIZANDO CELDA 17:\n",
      "   üìè Longitud: 44975 caracteres\n",
      "   üìÑ L√≠neas: 1074\n",
      "   ‚úÖ Sintaxis v√°lida\n",
      "   ‚úÖ No hay problemas detectados\n",
      "\n",
      "üî¨ ANALIZANDO CELDA 18:\n",
      "   üìè Longitud: 23 caracteres\n",
      "   üìÑ L√≠neas: 1\n",
      "   ‚úÖ Sintaxis v√°lida\n",
      "   ‚úÖ No hay problemas detectados\n",
      "\n",
      "üî¨ ANALIZANDO CELDA 19:\n",
      "   üìè Longitud: 714 caracteres\n",
      "   üìÑ L√≠neas: 17\n",
      "   ‚úÖ Sintaxis v√°lida\n",
      "   ‚úÖ No hay problemas detectados\n",
      "\n",
      "üî¨ ANALIZANDO CELDA 20:\n",
      "   üìè Longitud: 46573 caracteres\n",
      "   üìÑ L√≠neas: 1114\n",
      "   ‚úÖ Sintaxis v√°lida\n",
      "   ‚úÖ No hay problemas detectados\n",
      "\n",
      "üî¨ ANALIZANDO CELDA 21:\n",
      "   üìè Longitud: 30 caracteres\n",
      "   üìÑ L√≠neas: 1\n",
      "   ‚úÖ Sintaxis v√°lida\n",
      "   ‚úÖ No hay problemas detectados\n",
      "\n",
      "üî¨ ANALIZANDO CELDA 22:\n",
      "   üìè Longitud: 146500 caracteres\n",
      "   üìÑ L√≠neas: 3368\n",
      "   ‚úÖ Sintaxis v√°lida\n",
      "   ‚úÖ No hay problemas detectados\n",
      "\n",
      "üî¨ ANALIZANDO CELDA 23:\n",
      "   üìè Longitud: 15242 caracteres\n",
      "   üìÑ L√≠neas: 376\n",
      "   ‚úÖ Sintaxis v√°lida\n",
      "   ‚úÖ No hay problemas detectados\n",
      "\n",
      "üî¨ ANALIZANDO CELDA 24:\n",
      "   üìè Longitud: 5539 caracteres\n",
      "   üìÑ L√≠neas: 136\n",
      "   ‚úÖ Sintaxis v√°lida\n",
      "   ‚úÖ No hay problemas detectados\n",
      "\n",
      "üî¨ ANALIZANDO CELDA 25:\n",
      "   üìè Longitud: 4797 caracteres\n",
      "   üìÑ L√≠neas: 207\n",
      "   ‚úÖ Sintaxis v√°lida\n",
      "   ‚úÖ No hay problemas detectados\n",
      "\n",
      "üî¨ ANALIZANDO CELDA 26:\n",
      "   üìè Longitud: 12922 caracteres\n",
      "   üìÑ L√≠neas: 388\n",
      "   ‚úÖ Sintaxis v√°lida\n",
      "   ‚úÖ No hay problemas detectados\n",
      "\n",
      "üî¨ ANALIZANDO CELDA 27:\n",
      "   üìè Longitud: 9589 caracteres\n",
      "   üìÑ L√≠neas: 218\n",
      "   ‚úÖ Sintaxis v√°lida\n",
      "   ‚úÖ No hay problemas detectados\n",
      "\n",
      "üî¨ ANALIZANDO CELDA 28:\n",
      "   üìè Longitud: 17760 caracteres\n",
      "   üìÑ L√≠neas: 728\n",
      "   ‚úÖ Sintaxis v√°lida\n",
      "   ‚úÖ No hay problemas detectados\n",
      "\n",
      "üî¨ ANALIZANDO CELDA 29:\n",
      "   üìè Longitud: 33075 caracteres\n",
      "   üìÑ L√≠neas: 821\n",
      "   ‚ùå Error de sintaxis en l√≠nea 488: invalid syntax\n",
      "   üìä Total de problemas en esta celda: 1\n",
      "\n",
      "üî¨ ANALIZANDO CELDA 30:\n",
      "   üìè Longitud: 3163 caracteres\n",
      "   üìÑ L√≠neas: 81\n",
      "   ‚ùå Error de sintaxis en l√≠nea 17: unterminated triple-quoted string literal (detected at line 81)\n",
      "   üìä Total de problemas en esta celda: 1\n",
      "\n",
      "üìã RESUMEN COMPLETO DE PROBLEMAS DETECTADOS:\n",
      "==================================================\n",
      "üìä ESTAD√çSTICAS:\n",
      "   ‚Ä¢ Celdas con problemas: 3\n",
      "   ‚Ä¢ Errores de sintaxis: 2\n",
      "   ‚Ä¢ Problemas con strings: 0\n",
      "   ‚Ä¢ Code smells: 0\n",
      "   ‚Ä¢ Advertencias: 1\n",
      "\n",
      "üéØ CELDAS M√ÅS PROBLEM√ÅTICAS:\n",
      "   1. Celda 29: 1 problemas cr√≠ticos\n",
      "      ‚Ä¢ 1 errores de sintaxis\n",
      "   2. Celda 30: 1 problemas cr√≠ticos\n",
      "      ‚Ä¢ 1 errores de sintaxis\n",
      "\n",
      "‚è∞ An√°lisis completado: 14:19:00\n"
     ]
    }
   ],
   "source": [
    "# ================================================================================================\n",
    "# PASO 2: EJECUTAR EL DETECTIVE EN TU NOTEBOOK\n",
    "# ================================================================================================\n",
    "\n",
    "# Ruta de tu notebook\n",
    "NOTEBOOK_PATH = r\"C:\\Users\\Alicia_Piero\\Documents\\Repo_AIEP\\MIP_QUILLOTA\\Proyecto_METGO_3D\\Sistema de Pron√≥stico Meteorol√≥gico y Gesti√≥n Agr√≠cola MIP Quillota.ipynb\"\n",
    "\n",
    "print(\"üïµÔ∏è DETECTIVE DE ERRORES - MIP QUILLOTA\")\n",
    "print(\"=\" * 45)\n",
    "print(f\"üìÅ Analizando: {os.path.basename(NOTEBOOK_PATH)}\")\n",
    "\n",
    "# Crear detective\n",
    "detective_mip = PythonErrorDetective(NOTEBOOK_PATH)\n",
    "\n",
    "# Ejecutar an√°lisis\n",
    "success = detective_mip.load_and_analyze_notebook()\n",
    "\n",
    "print(f\"\\n‚è∞ An√°lisis completado: {datetime.now().strftime('%H:%M:%S')}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "844339d4-6183-4882-8ba6-eef0142b616a",
   "metadata": {},
   "outputs": [
    {
     "ename": "FileNotFoundError",
     "evalue": "[Errno 2] No such file or directory: 'C:\\\\‚Ä¶\\\\MIP Quillota.ipynb'",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mAttributeError\u001b[0m                            Traceback (most recent call last)",
      "File \u001b[1;32mD:\\Miguel\\Anaconda_AIEP\\Lib\\site-packages\\nbformat\\__init__.py:169\u001b[0m, in \u001b[0;36mread\u001b[1;34m(fp, as_version, capture_validation_error, **kwargs)\u001b[0m\n\u001b[0;32m    168\u001b[0m \u001b[38;5;28;01mtry\u001b[39;00m:\n\u001b[1;32m--> 169\u001b[0m     buf \u001b[38;5;241m=\u001b[39m fp\u001b[38;5;241m.\u001b[39mread()\n\u001b[0;32m    170\u001b[0m \u001b[38;5;28;01mexcept\u001b[39;00m \u001b[38;5;167;01mAttributeError\u001b[39;00m:\n",
      "\u001b[1;31mAttributeError\u001b[0m: 'str' object has no attribute 'read'",
      "\nDuring handling of the above exception, another exception occurred:\n",
      "\u001b[1;31mFileNotFoundError\u001b[0m                         Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[7], line 4\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;21;01mpathlib\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;28;01mimport\u001b[39;00m Path\n\u001b[0;32m      2\u001b[0m \u001b[38;5;28;01mimport\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;21;01mnbformat\u001b[39;00m\u001b[38;5;241m,\u001b[39m\u001b[38;5;250m \u001b[39m\u001b[38;5;21;01mtextwrap\u001b[39;00m\n\u001b[1;32m----> 4\u001b[0m nb \u001b[38;5;241m=\u001b[39m nbformat\u001b[38;5;241m.\u001b[39mread(\u001b[38;5;124mr\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mC:\u001b[39m\u001b[38;5;124m\\\u001b[39m\u001b[38;5;124m‚Ä¶\u001b[39m\u001b[38;5;124m\\\u001b[39m\u001b[38;5;124mMIP Quillota.ipynb\u001b[39m\u001b[38;5;124m\"\u001b[39m, as_version\u001b[38;5;241m=\u001b[39m\u001b[38;5;241m4\u001b[39m)\n\u001b[0;32m      5\u001b[0m cell_29_src \u001b[38;5;241m=\u001b[39m nb\u001b[38;5;241m.\u001b[39mcells[\u001b[38;5;241m28\u001b[39m]\u001b[38;5;241m.\u001b[39msource            \u001b[38;5;66;03m# √≠ndice base 0\u001b[39;00m\n\u001b[0;32m      6\u001b[0m tmp \u001b[38;5;241m=\u001b[39m Path(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124m_celda29.py\u001b[39m\u001b[38;5;124m\"\u001b[39m)\n",
      "File \u001b[1;32mD:\\Miguel\\Anaconda_AIEP\\Lib\\site-packages\\nbformat\\__init__.py:171\u001b[0m, in \u001b[0;36mread\u001b[1;34m(fp, as_version, capture_validation_error, **kwargs)\u001b[0m\n\u001b[0;32m    169\u001b[0m     buf \u001b[38;5;241m=\u001b[39m fp\u001b[38;5;241m.\u001b[39mread()\n\u001b[0;32m    170\u001b[0m \u001b[38;5;28;01mexcept\u001b[39;00m \u001b[38;5;167;01mAttributeError\u001b[39;00m:\n\u001b[1;32m--> 171\u001b[0m     \u001b[38;5;28;01mwith\u001b[39;00m \u001b[38;5;28mopen\u001b[39m(fp, encoding\u001b[38;5;241m=\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mutf8\u001b[39m\u001b[38;5;124m\"\u001b[39m) \u001b[38;5;28;01mas\u001b[39;00m f:  \u001b[38;5;66;03m# noqa: PTH123\u001b[39;00m\n\u001b[0;32m    172\u001b[0m         \u001b[38;5;28;01mreturn\u001b[39;00m reads(f\u001b[38;5;241m.\u001b[39mread(), as_version, capture_validation_error, \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwargs)\n\u001b[0;32m    174\u001b[0m \u001b[38;5;28;01mreturn\u001b[39;00m reads(buf, as_version, capture_validation_error, \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwargs)\n",
      "\u001b[1;31mFileNotFoundError\u001b[0m: [Errno 2] No such file or directory: 'C:\\\\‚Ä¶\\\\MIP Quillota.ipynb'"
     ]
    }
   ],
   "source": [
    "from pathlib import Path\n",
    "import nbformat, textwrap\n",
    "\n",
    "nb = nbformat.read(r\"C:\\‚Ä¶\\MIP Quillota.ipynb\", as_version=4)\n",
    "cell_29_src = nb.cells[28].source            # √≠ndice base 0\n",
    "tmp = Path(\"_celda29.py\")\n",
    "tmp.write_text(cell_29_src, encoding=\"utf8\")\n",
    "\n",
    "# visualizar con n√∫meros de l√≠nea\n",
    "for i, line in enumerate(cell_29_src.splitlines(), 1):\n",
    "    print(f\"{i:4}: {line}\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4cc85f95-dcc8-46b3-be6d-a68037d5591e",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "# ================================================================================================\n",
    "# INSPECTOR DETALLADO DE ERRORES - AN√ÅLISIS PROFUNDO\n",
    "# ================================================================================================\n",
    "\n",
    "class DetailedErrorInspector:\n",
    "    def __init__(self, notebook_path):\n",
    "        self.notebook_path = notebook_path\n",
    "        self.notebook = None\n",
    "        self.detailed_errors = {}\n",
    "        \n",
    "    def deep_inspect_specific_cells(self):\n",
    "        \"\"\"Inspecci√≥n profunda de las celdas problem√°ticas\"\"\"\n",
    "        print(\"üî¨ INSPECTOR DETALLADO DE ERRORES ESPEC√çFICOS:\")\n",
    "        print(\"=\" * 52)\n",
    "        \n",
    "        with open(self.notebook_path, 'r', encoding='utf-8') as f:\n",
    "            self.notebook = nbformat.read(f, as_version=4)\n",
    "        \n",
    "        # Inspeccionar celdas problem√°ticas identificadas\n",
    "        problematic_cells = [\n",
    "            (2, \"Exceso de imports\"),\n",
    "            (29, \"Error de sintaxis l√≠nea 477\"), \n",
    "            (30, \"String triple no cerrado\")\n",
    "        ]\n",
    "        \n",
    "        for cell_num, description in problematic_cells:\n",
    "            print(f\"\\nüéØ INSPECCI√ìN DETALLADA - CELDA {cell_num}: {description}\")\n",
    "            print(\"-\" * 60)\n",
    "            self._inspect_cell_deeply(cell_num - 1, description)\n",
    "        \n",
    "        return self.detailed_errors\n",
    "    \n",
    "    def _inspect_cell_deeply(self, cell_index, error_description):\n",
    "        \"\"\"Inspecci√≥n profunda de una celda espec√≠fica\"\"\"\n",
    "        cell = self.notebook.cells[cell_index]\n",
    "        cell_num = cell_index + 1\n",
    "        source = cell.source\n",
    "        lines = source.split('\\n')\n",
    "        \n",
    "        self.detailed_errors[cell_num] = {\n",
    "            'description': error_description,\n",
    "            'source_length': len(source),\n",
    "            'line_count': len(lines),\n",
    "            'analysis': {},\n",
    "            'code_snippets': {},\n",
    "            'recommendations': []\n",
    "        }\n",
    "        \n",
    "        print(f\"üìä Estad√≠sticas de la celda {cell_num}:\")\n",
    "        print(f\"   ‚Ä¢ Longitud total: {len(source):,} caracteres\")\n",
    "        print(f\"   ‚Ä¢ N√∫mero de l√≠neas: {len(lines):,}\")\n",
    "        print(f\"   ‚Ä¢ Promedio chars/l√≠nea: {len(source)/len(lines):.1f}\")\n",
    "        \n",
    "        if cell_num == 2:\n",
    "            self._analyze_imports_excess(cell_num, source, lines)\n",
    "        elif cell_num == 29:\n",
    "            self._analyze_syntax_error_line_477(cell_num, source, lines)\n",
    "        elif cell_num == 30:\n",
    "            self._analyze_triple_quote_issue(cell_num, source, lines)\n",
    "    \n",
    "    def _analyze_imports_excess(self, cell_num, source, lines):\n",
    "        \"\"\"An√°lisis detallado del exceso de imports en celda 2\"\"\"\n",
    "        print(f\"\\nüîç AN√ÅLISIS DETALLADO: Exceso de imports\")\n",
    "        \n",
    "        imports = []\n",
    "        other_code = []\n",
    "        import_categories = {\n",
    "            'standard': [],\n",
    "            'data_science': [],\n",
    "            'visualization': [],\n",
    "            'ml': [],\n",
    "            'web_api': [],\n",
    "            'others': []\n",
    "        }\n",
    "        \n",
    "        for i, line in enumerate(lines, 1):\n",
    "            if line.strip().startswith(('import ', 'from ')):\n",
    "                imports.append({'line_num': i, 'code': line.strip()})\n",
    "                \n",
    "                # Categorizar import\n",
    "                line_lower = line.lower()\n",
    "                if any(lib in line_lower for lib in ['os', 'sys', 'datetime', 'json', 're', 'math']):\n",
    "                    import_categories['standard'].append(line.strip())\n",
    "                elif any(lib in line_lower for lib in ['pandas', 'numpy', 'scipy']):\n",
    "                    import_categories['data_science'].append(line.strip())\n",
    "                elif any(lib in line_lower for lib in ['matplotlib', 'seaborn', 'plotly', 'bokeh']):\n",
    "                    import_categories['visualization'].append(line.strip())\n",
    "                elif any(lib in line_lower for lib in ['sklearn', 'tensorflow', 'keras', 'torch']):\n",
    "                    import_categories['ml'].append(line.strip())\n",
    "                elif any(lib in line_lower for lib in ['requests', 'urllib', 'api', 'http']):\n",
    "                    import_categories['web_api'].append(line.strip())\n",
    "                else:\n",
    "                    import_categories['others'].append(line.strip())\n",
    "            else:\n",
    "                if line.strip():\n",
    "                    other_code.append({'line_num': i, 'code': line.strip()})\n",
    "        \n",
    "        print(f\"üìà Estad√≠sticas de imports:\")\n",
    "        print(f\"   ‚Ä¢ Total imports: {len(imports)}\")\n",
    "        print(f\"   ‚Ä¢ Librer√≠as est√°ndar: {len(import_categories['standard'])}\")\n",
    "        print(f\"   ‚Ä¢ Data Science: {len(import_categories['data_science'])}\")\n",
    "        print(f\"   ‚Ä¢ Visualizaci√≥n: {len(import_categories['visualization'])}\")\n",
    "        print(f\"   ‚Ä¢ Machine Learning: {len(import_categories['ml'])}\")\n",
    "        print(f\"   ‚Ä¢ Web/API: {len(import_categories['web_api'])}\")\n",
    "        print(f\"   ‚Ä¢ Otros: {len(import_categories['others'])}\")\n",
    "        print(f\"   ‚Ä¢ L√≠neas de c√≥digo adicional: {len(other_code)}\")\n",
    "        \n",
    "        # Mostrar algunos ejemplos\n",
    "        print(f\"\\nüí° EJEMPLOS DE IMPORTS POR CATEGOR√çA:\")\n",
    "        for category, imports_list in import_categories.items():\n",
    "            if imports_list:\n",
    "                print(f\"   üîπ {category.title()}:\")\n",
    "                for imp in imports_list[:3]:  # Primeros 3\n",
    "                    print(f\"      ‚Ä¢ {imp}\")\n",
    "                if len(imports_list) > 3:\n",
    "                    print(f\"      ... y {len(imports_list) - 3} m√°s\")\n",
    "        \n",
    "        # Guardar an√°lisis\n",
    "        self.detailed_errors[cell_num]['analysis'] = {\n",
    "            'total_imports': len(imports),\n",
    "            'categories': {k: len(v) for k, v in import_categories.items()},\n",
    "            'other_code_lines': len(other_code),\n",
    "            'import_details': import_categories\n",
    "        }\n",
    "        \n",
    "        # Recomendaciones espec√≠ficas\n",
    "        recommendations = [\n",
    "            \"Separar imports en celda dedicada al inicio del notebook\",\n",
    "            \"Agrupar imports por categor√≠as (est√°ndar, data science, ML, etc.)\",\n",
    "            \"Mover c√≥digo funcional a celdas separadas\",\n",
    "            \"Considerar crear m√≥dulos .py para funciones reutilizables\"\n",
    "        ]\n",
    "        \n",
    "        self.detailed_errors[cell_num]['recommendations'] = recommendations\n",
    "        \n",
    "        print(f\"\\n‚ú® RECOMENDACIONES:\")\n",
    "        for i, rec in enumerate(recommendations, 1):\n",
    "            print(f\"   {i}. {rec}\")\n",
    "    \n",
    "    def _analyze_syntax_error_line_477(self, cell_num, source, lines):\n",
    "        \"\"\"An√°lisis detallado del error de sintaxis en l√≠nea 477\"\"\"\n",
    "        print(f\"\\nüîç AN√ÅLISIS DETALLADO: Error de sintaxis l√≠nea 477\")\n",
    "        \n",
    "        if len(lines) < 477:\n",
    "            print(f\"‚ùå ERROR: La celda solo tiene {len(lines)} l√≠neas, no 477\")\n",
    "            return\n",
    "        \n",
    "        # Analizar l√≠nea problem√°tica y contexto\n",
    "        problem_line_idx = 476  # l√≠nea 477 (√≠ndice 476)\n",
    "        problem_line = lines[problem_line_idx]\n",
    "        \n",
    "        # Contexto alrededor del error (5 l√≠neas antes y despu√©s)\n",
    "        context_start = max(0, problem_line_idx - 5)\n",
    "        context_end = min(len(lines), problem_line_idx + 6)\n",
    "        context_lines = lines[context_start:context_end]\n",
    "        \n",
    "        print(f\"üìç L√çNEA PROBLEM√ÅTICA 477:\")\n",
    "        print(f\"   ‚îÇ {problem_line}\")\n",
    "        print(f\"   ‚îî‚îÄ Longitud: {len(problem_line)} caracteres\")\n",
    "        \n",
    "        print(f\"\\nüìã CONTEXTO (l√≠neas {context_start + 1}-{context_end}):\")\n",
    "        for i, line in enumerate(context_lines, context_start + 1):\n",
    "            marker = \"üëâ\" if i == 477 else \"  \"\n",
    "            print(f\"   {marker} {i:3d}: {line[:80]}{'...' if len(line) > 80 else ''}\")\n",
    "        \n",
    "        # An√°lisis espec√≠fico de la l√≠nea problem√°tica\n",
    "        analysis = {\n",
    "            'line_content': problem_line,\n",
    "            'line_length': len(problem_line),\n",
    "            'parentheses_balance': problem_line.count('(') - problem_line.count(')'),\n",
    "            'brackets_balance': problem_line.count('[') - problem_line.count(']'),\n",
    "            'braces_balance': problem_line.count('{') - problem_line.count('}'),\n",
    "            'single_quotes': problem_line.count(\"'\"),\n",
    "            'double_quotes': problem_line.count('\"'),\n",
    "            'has_colon': ':' in problem_line,\n",
    "            'ends_with_comma': problem_line.rstrip().endswith(','),\n",
    "            'potential_keywords': []\n",
    "        }\n",
    "        \n",
    "        # Buscar keywords que podr√≠an necesitar ':'\n",
    "        keywords_needing_colon = ['if', 'elif', 'else', 'for', 'while', 'def', 'class', 'try', 'except', 'finally', 'with']\n",
    "        for keyword in keywords_needing_colon:\n",
    "            if f' {keyword} ' in f' {problem_line} ' or problem_line.strip().startswith(f'{keyword} '):\n",
    "                analysis['potential_keywords'].append(keyword)\n",
    "        \n",
    "        print(f\"\\nüîç AN√ÅLISIS DE LA L√çNEA 477:\")\n",
    "        print(f\"   ‚Ä¢ Balance par√©ntesis: {analysis['parentheses_balance']} {'‚ö†Ô∏è' if analysis['parentheses_balance'] != 0 else '‚úÖ'}\")\n",
    "        print(f\"   ‚Ä¢ Balance corchetes: {analysis['brackets_balance']} {'‚ö†Ô∏è' if analysis['brackets_balance'] != 0 else '‚úÖ'}\")\n",
    "        print(f\"   ‚Ä¢ Balance llaves: {analysis['braces_balance']} {'‚ö†Ô∏è' if analysis['braces_balance'] != 0 else '‚úÖ'}\")\n",
    "        print(f\"   ‚Ä¢ Comillas simples: {analysis['single_quotes']} {'‚ö†Ô∏è' if analysis['single_quotes'] % 2 != 0 else '‚úÖ'}\")\n",
    "        print(f\"   ‚Ä¢ Comillas dobles: {analysis['double_quotes']} {'‚ö†Ô∏è' if analysis['double_quotes'] % 2 != 0 else '‚úÖ'}\")\n",
    "        print(f\"   ‚Ä¢ Tiene dos puntos: {'‚úÖ' if analysis['has_colon'] else '‚ùå'}\")\n",
    "        print(f\"   ‚Ä¢ Termina con coma: {'‚úÖ' if analysis['ends_with_comma'] else '‚ùå'}\")\n",
    "        \n",
    "        if analysis['potential_keywords']:\n",
    "            print(f\"   ‚Ä¢ Keywords detectados: {', '.join(analysis['potential_keywords'])}\")\n",
    "        \n",
    "        # Guardar an√°lisis detallado\n",
    "        self.detailed_errors[cell_num]['analysis'] = analysis\n",
    "        self.detailed_errors[cell_num]['code_snippets'] = {\n",
    "            'problem_line': problem_line,\n",
    "            'context': context_lines,\n",
    "            'line_number': 477\n",
    "        }\n",
    "        \n",
    "        # Generar recomendaciones espec√≠ficas\n",
    "        recommendations = []\n",
    "        \n",
    "        if analysis['parentheses_balance'] > 0:\n",
    "            recommendations.append(f\"Agregar {analysis['parentheses_balance']} par√©ntesis de cierre ')'\")\n",
    "        elif analysis['parentheses_balance'] < 0:\n",
    "            recommendations.append(f\"Eliminar {abs(analysis['parentheses_balance'])} par√©ntesis de cierre extra\")\n",
    "        \n",
    "        if analysis['brackets_balance'] > 0:\n",
    "            recommendations.append(f\"Agregar {analysis['brackets_balance']} corchetes de cierre ']'\")\n",
    "        elif analysis['brackets_balance'] < 0:\n",
    "            recommendations.append(f\"Eliminar {abs(analysis['brackets_balance'])} corchetes de cierre extra\")\n",
    "        \n",
    "        if analysis['single_quotes'] % 2 != 0:\n",
    "            recommendations.append(\"Balancear comillas simples (n√∫mero impar detectado)\")\n",
    "        \n",
    "        if analysis['double_quotes'] % 2 != 0:\n",
    "            recommendations.append(\"Balancear comillas dobles (n√∫mero impar detectado)\")\n",
    "        \n",
    "        if analysis['potential_keywords'] and not analysis['has_colon']:\n",
    "            recommendations.append(f\"Agregar ':' al final (keyword '{analysis['potential_keywords'][0]}' detectado)\")\n",
    "        \n",
    "        if not recommendations:\n",
    "            recommendations.append(\"Revisar sintaxis manualmente - error no identificado autom√°ticamente\")\n",
    "        \n",
    "        self.detailed_errors[cell_num]['recommendations'] = recommendations\n",
    "        \n",
    "        print(f\"\\n‚ú® RECOMENDACIONES ESPEC√çFICAS:\")\n",
    "        for i, rec in enumerate(recommendations, 1):\n",
    "            print(f\"   {i}. {rec}\")\n",
    "    \n",
    "    def _analyze_triple_quote_issue(self, cell_num, source, lines):\n",
    "        \"\"\"An√°lisis detallado del problema de string triple\"\"\"\n",
    "        print(f\"\\nüîç AN√ÅLISIS DETALLADO: String triple no cerrado\")\n",
    "        \n",
    "        # Analizar patrones de strings triples\n",
    "        triple_patterns = ['\"\"\"', \"'''\"]\n",
    "        analysis = {}\n",
    "        \n",
    "        for pattern in triple_patterns:\n",
    "            count = source.count(pattern)\n",
    "            positions = []\n",
    "            \n",
    "            # Encontrar todas las posiciones\n",
    "            start = 0\n",
    "            while True:\n",
    "                pos = source.find(pattern, start)\n",
    "                if pos == -1:\n",
    "                    break\n",
    "                \n",
    "                # Determinar n√∫mero de l√≠nea\n",
    "                line_num = source[:pos].count('\\n') + 1\n",
    "                positions.append({'position': pos, 'line': line_num})\n",
    "                start = pos + len(pattern)\n",
    "            \n",
    "            analysis[pattern] = {\n",
    "                'count': count,\n",
    "                'is_balanced': count % 2 == 0,\n",
    "                'positions': positions\n",
    "            }\n",
    "        \n",
    "        print(f\"üìä AN√ÅLISIS DE STRINGS TRIPLES:\")\n",
    "        for pattern, info in analysis.items():\n",
    "            status = \"‚úÖ Balanceado\" if info['is_balanced'] else \"‚ùå Desbalanceado\"\n",
    "            print(f\"   ‚Ä¢ {pattern}: {info['count']} ocurrencias - {status}\")\n",
    "            \n",
    "            if info['positions']:\n",
    "                print(f\"     Posiciones encontradas:\")\n",
    "                for pos_info in info['positions']:\n",
    "                    line_content = lines[pos_info['line'] - 1] if pos_info['line'] <= len(lines) else \"N/A\"\n",
    "                    print(f\"       - L√≠nea {pos_info['line']}: {line_content.strip()[:50]}...\")\n",
    "        \n",
    "        # Identificar el problema espec√≠fico\n",
    "        problematic_pattern = None\n",
    "        for pattern, info in analysis.items():\n",
    "            if not info['is_balanced']:\n",
    "                problematic_pattern = pattern\n",
    "                break\n",
    "        \n",
    "        if problematic_pattern:\n",
    "            problem_info = analysis[problematic_pattern]\n",
    "            print(f\"\\nüéØ PROBLEMA IDENTIFICADO:\")\n",
    "            print(f\"   ‚Ä¢ Patr√≥n problem√°tico: {problematic_pattern}\")\n",
    "            print(f\"   ‚Ä¢ √öltima posici√≥n: L√≠nea {problem_info['positions'][-1]['line']}\")\n",
    "            \n",
    "            # Mostrar contexto de la √∫ltima ocurrencia\n",
    "            last_line = problem_info['positions'][-1]['line']\n",
    "            context_start = max(1, last_line - 3)\n",
    "            context_end = min(len(lines), last_line + 4)\n",
    "            \n",
    "            print(f\"\\nüìã CONTEXTO (l√≠neas {context_start}-{context_end}):\")\n",
    "            for i in range(context_start, context_end + 1):\n",
    "                if i <= len(lines):\n",
    "                    marker = \"üëâ\" if i == last_line else \"  \"\n",
    "                    line_content = lines[i-1] if i > 0 else \"\"\n",
    "                    print(f\"   {marker} {i:3d}: {line_content}\")\n",
    "        \n",
    "        # Guardar an√°lisis\n",
    "        self.detailed_errors[cell_num]['analysis'] = analysis\n",
    "        self.detailed_errors[cell_num]['code_snippets'] = {\n",
    "            'first_lines': lines[:10],\n",
    "            'last_lines': lines[-10:],\n",
    "            'total_lines': len(lines)\n",
    "        }\n",
    "        \n",
    "        # Recomendaciones\n",
    "        recommendations = []\n",
    "        if problematic_pattern:\n",
    "            recommendations.append(f\"Agregar {problematic_pattern} al final del c√≥digo para cerrar string\")\n",
    "            recommendations.append(\"Revisar estructura del string para asegurar que el contenido sea correcto\")\n",
    "            recommendations.append(\"Considerar dividir strings muy largos en secciones m√°s peque√±as\")\n",
    "        else:\n",
    "            recommendations.append(\"Revisar manualmente la estructura de strings triples\")\n",
    "        \n",
    "        self.detailed_errors[cell_num]['recommendations'] = recommendations\n",
    "        \n",
    "        print(f\"\\n‚ú® RECOMENDACIONES:\")\n",
    "        for i, rec in enumerate(recommendations, 1):\n",
    "            print(f\"   {i}. {rec}\")\n",
    "    \n",
    "    def generate_detailed_report(self):\n",
    "        \"\"\"Genera reporte detallado completo\"\"\"\n",
    "        print(f\"\\nüìã REPORTE DETALLADO COMPLETO:\")\n",
    "        print(\"=\" * 50)\n",
    "        \n",
    "        for cell_num, details in self.detailed_errors.items():\n",
    "            print(f\"\\nüéØ CELDA {cell_num}: {details['description']}\")\n",
    "            print(f\"   üìä Tama√±o: {details['source_length']:,} chars, {details['line_count']:,} l√≠neas\")\n",
    "            print(f\"   üîß Recomendaciones: {len(details['recommendations'])}\")\n",
    "            \n",
    "        return self.detailed_errors\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d359de3f-0012-4374-a590-71aa2283daae",
   "metadata": {},
   "outputs": [],
   "source": [
    "# ============================================================================\n",
    "# EJECUTAR INSPECTOR DETALLADO\n",
    "# ============================================================================\n",
    "\n",
    "print(\"üöÄ INICIANDO INSPECCI√ìN DETALLADA:\")\n",
    "print(\"=\" * 40)\n",
    "\n",
    "# Crear inspector\n",
    "detailed_inspector = DetailedErrorInspector(NOTEBOOK_PATH)\n",
    "\n",
    "# Ejecutar inspecci√≥n profunda\n",
    "detailed_errors = detailed_inspector.deep_inspect_specific_cells()\n",
    "\n",
    "# Generar reporte completo\n",
    "full_report = detailed_inspector.generate_detailed_report()\n",
    "\n",
    "print(f\"\\n‚úÖ INSPECCI√ìN DETALLADA COMPLETADA\")\n",
    "print(\"üéØ SIGUIENTE PASO: Generar proyecto nuevo ordenado basado en este an√°lisis\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cb49e968-99b0-46ee-8f3f-35848283b5cd",
   "metadata": {},
   "outputs": [],
   "source": [
    "# ===============================================================================\n",
    "# üîß CONFIGURACI√ìN E IMPORTS - SISTEMA MIP QUILLOTA (REPARADO)\n",
    "# Manejo correcto del contexto de Streamlit\n",
    "# ===============================================================================\n",
    "\n",
    "import sys\n",
    "import os\n",
    "import warnings\n",
    "from pathlib import Path\n",
    "from datetime import datetime\n",
    "\n",
    "# ===============================================================================\n",
    "# SUPRESI√ìN DE WARNINGS ESPEC√çFICOS - REPARADO\n",
    "# ===============================================================================\n",
    "\n",
    "# Filtrar solo los warnings molestos, mantener los importantes\n",
    "warnings.filterwarnings('ignore', message='.*ScriptRunContext.*')\n",
    "warnings.filterwarnings('ignore', message='.*missing ScriptRunContext.*')\n",
    "warnings.filterwarnings('ignore', category=FutureWarning, module='streamlit')\n",
    "\n",
    "# Configurar variables de entorno para Streamlit\n",
    "os.environ['STREAMLIT_BROWSER_GATHER_USAGE_STATS'] = 'false'\n",
    "os.environ['STREAMLIT_THEME_BASE'] = 'light'\n",
    "\n",
    "print(\"üöÄ Inicializando Sistema MIP Quillota...\")\n",
    "print(\"‚öôÔ∏è Configuraci√≥n de warnings optimizada\")\n",
    "print(\"=\" * 60)\n",
    "\n",
    "# ===============================================================================\n",
    "# DETECCI√ìN DE CONTEXTO DE EJECUCI√ìN - MEJORADO\n",
    "# ===============================================================================\n",
    "\n",
    "def detect_execution_context():\n",
    "    \"\"\"Detecta si estamos ejecutando en notebook, streamlit o script\"\"\"\n",
    "    try:\n",
    "        # Verificar si estamos en Jupyter\n",
    "        if 'ipykernel' in sys.modules:\n",
    "            return 'jupyter'\n",
    "        # Verificar si estamos en Streamlit\n",
    "        elif 'streamlit' in sys.modules:\n",
    "            try:\n",
    "                import streamlit as st_test\n",
    "                # Verificar si el contexto de Streamlit est√° activo\n",
    "                try:\n",
    "                    st_test.session_state\n",
    "                    return 'streamlit_app'\n",
    "                except:\n",
    "                    return 'streamlit_script'\n",
    "            except:\n",
    "                return 'streamlit_import_only'\n",
    "        else:\n",
    "            return 'python_script'\n",
    "    except Exception as e:\n",
    "        print(f\"‚ö†Ô∏è Error detectando contexto: {e}\")\n",
    "        return 'unknown'\n",
    "\n",
    "EXECUTION_CONTEXT = detect_execution_context()\n",
    "print(f\"üéØ Contexto de ejecuci√≥n detectado: {EXECUTION_CONTEXT}\")\n",
    "\n",
    "# ===============================================================================\n",
    "# IMPORTS B√ÅSICOS - SEGUROS\n",
    "# ===============================================================================\n",
    "\n",
    "try:\n",
    "    import pandas as pd\n",
    "    import numpy as np\n",
    "    from datetime import datetime, timedelta, date\n",
    "    import json\n",
    "    import pickle\n",
    "    \n",
    "    # Configurar pandas\n",
    "    pd.set_option('display.max_columns', 20)\n",
    "    pd.set_option('display.width', 1000)\n",
    "    pd.set_option('display.precision', 2)\n",
    "    \n",
    "    print(\"‚úÖ Imports b√°sicos cargados correctamente\")\n",
    "except ImportError as e:\n",
    "    print(f\"‚ùå Error en imports b√°sicos: {e}\")\n",
    "    raise\n",
    "\n",
    "# ===============================================================================\n",
    "# IMPORTS DE VISUALIZACI√ìN - SEGUROS\n",
    "# ===============================================================================\n",
    "\n",
    "try:\n",
    "    # Matplotlib y Seaborn\n",
    "    import matplotlib.pyplot as plt\n",
    "    import matplotlib.dates as mdates\n",
    "    import seaborn as sns\n",
    "    \n",
    "    # Configuraci√≥n segura de matplotlib\n",
    "    plt.style.use('default')\n",
    "    plt.rcParams['figure.figsize'] = (12, 8)\n",
    "    plt.rcParams['font.size'] = 10\n",
    "    plt.rcParams['axes.grid'] = True\n",
    "    \n",
    "    print(\"‚úÖ Matplotlib y Seaborn cargados\")\n",
    "except ImportError as e:\n",
    "    print(f\"‚ö†Ô∏è Error en matplotlib: {e}\")\n",
    "\n",
    "try:\n",
    "    # Plotly\n",
    "    import plotly.express as px\n",
    "    import plotly.graph_objects as go\n",
    "    from plotly.subplots import make_subplots\n",
    "    import plotly.figure_factory as ff\n",
    "    \n",
    "    print(\"‚úÖ Plotly cargado\")\n",
    "    PLOTLY_AVAILABLE = True\n",
    "except ImportError as e:\n",
    "    print(f\"‚ö†Ô∏è Plotly no disponible: {e}\")\n",
    "    PLOTLY_AVAILABLE = False\n",
    "\n",
    "# ===============================================================================\n",
    "# IMPORTACI√ìN REPARADA DE STREAMLIT\n",
    "# ===============================================================================\n",
    "\n",
    "class StreamlitSafeManager:\n",
    "    \"\"\"Manager que maneja Streamlit de forma completamente segura\"\"\"\n",
    "    \n",
    "    def __init__(self):\n",
    "        self.available = False\n",
    "        self.st = None\n",
    "        self.context = EXECUTION_CONTEXT\n",
    "        self._initialize_streamlit_safe()\n",
    "    \n",
    "    def _initialize_streamlit_safe(self):\n",
    "        \"\"\"Inicializa Streamlit de la forma m√°s segura posible\"\"\"\n",
    "        \n",
    "        # Redirigir stderr temporalmente para evitar warnings\n",
    "        original_stderr = sys.stderr\n",
    "        \n",
    "        try:\n",
    "            # Crear un stderr silencioso\n",
    "            from io import StringIO\n",
    "            silent_stderr = StringIO()\n",
    "            sys.stderr = silent_stderr\n",
    "            \n",
    "            # Intentar importar streamlit\n",
    "            import streamlit as st_module\n",
    "            \n",
    "            # Restaurar stderr inmediatamente\n",
    "            sys.stderr = original_stderr\n",
    "            \n",
    "            # Configurar seg√∫n contexto\n",
    "            if self.context == 'streamlit_app':\n",
    "                # Contexto completo de Streamlit\n",
    "                self.st = st_module\n",
    "                self.available = True\n",
    "                print(\"‚úÖ Streamlit completamente disponible\")\n",
    "                \n",
    "            elif self.context in ['jupyter', 'python_script']:\n",
    "                # Crear wrapper compatible para notebooks\n",
    "                self.st = self._create_notebook_wrapper()\n",
    "                self.available = True\n",
    "                print(\"‚úÖ Streamlit en modo compatibilidad para notebook\")\n",
    "                \n",
    "            else:\n",
    "                # Contexto desconocido, usar wrapper b√°sico\n",
    "                self.st = self._create_basic_wrapper()\n",
    "                self.available = False\n",
    "                print(\"‚ö†Ô∏è Streamlit en modo b√°sico\")\n",
    "                \n",
    "        except ImportError:\n",
    "            # Restaurar stderr\n",
    "            sys.stderr = original_stderr\n",
    "            \n",
    "            # Streamlit no disponible, crear mock\n",
    "            self.st = self._create_mock_streamlit()\n",
    "            self.available = False\n",
    "            print(\"‚ö†Ô∏è Streamlit no instalado - usando mock\")\n",
    "            \n",
    "        except Exception as e:\n",
    "            # Restaurar stderr\n",
    "            sys.stderr = original_stderr\n",
    "            \n",
    "            # Error inesperado, usar mock\n",
    "            self.st = self._create_mock_streamlit()\n",
    "            self.available = False\n",
    "            print(f\"‚ö†Ô∏è Error inicializando Streamlit: {e}\")\n",
    "    \n",
    "    def _create_notebook_wrapper(self):\n",
    "        \"\"\"Crea wrapper optimizado para notebooks\"\"\"\n",
    "        \n",
    "        class NotebookStreamlitWrapper:\n",
    "            \"\"\"Wrapper que adapta Streamlit para notebooks\"\"\"\n",
    "            \n",
    "            def __init__(self):\n",
    "                self.session_state = {}\n",
    "                self._markdown_content = []\n",
    "            \n",
    "            def write(self, *args, **kwargs):\n",
    "                if args:\n",
    "                    print(f\"üìù {args[0]}\")\n",
    "                return self\n",
    "            \n",
    "            def markdown(self, text, **kwargs):\n",
    "                print(f\"üìÑ {text}\")\n",
    "                return self\n",
    "            \n",
    "            def header(self, text, **kwargs):\n",
    "                print(f\"\\n{'='*60}\")\n",
    "                print(f\"üìã {text.upper()}\")\n",
    "                print(f\"{'='*60}\")\n",
    "                return self\n",
    "            \n",
    "            def subheader(self, text, **kwargs):\n",
    "                print(f\"\\n{'-'*40}\")\n",
    "                print(f\"üìå {text}\")\n",
    "                print(f\"{'-'*40}\")\n",
    "                return self\n",
    "            \n",
    "            def metric(self, label, value, delta=None, **kwargs):\n",
    "                delta_text = f\" ({delta})\" if delta else \"\"\n",
    "                print(f\"üìä {label}: {value}{delta_text}\")\n",
    "                return self\n",
    "            \n",
    "            def columns(self, num_cols):\n",
    "                return [self for _ in range(num_cols)]\n",
    "            \n",
    "            def selectbox(self, label, options, **kwargs):\n",
    "                print(f\"üìã {label}: {options[0] if options else 'Sin opciones'}\")\n",
    "                return options[0] if options else None\n",
    "            \n",
    "            def button(self, label, **kwargs):\n",
    "                print(f\"üîò Bot√≥n: {label}\")\n",
    "                return False\n",
    "            \n",
    "            def sidebar(self):\n",
    "                return self\n",
    "            \n",
    "            def plotly_chart(self, fig, **kwargs):\n",
    "                print(\"üìà Gr√°fico de Plotly mostrado\")\n",
    "                if PLOTLY_AVAILABLE:\n",
    "                    fig.show()\n",
    "                return self\n",
    "            \n",
    "            def success(self, text):\n",
    "                print(f\"‚úÖ {text}\")\n",
    "                return self\n",
    "            \n",
    "            def warning(self, text):\n",
    "                print(f\"‚ö†Ô∏è {text}\")\n",
    "                return self\n",
    "            \n",
    "            def error(self, text):\n",
    "                print(f\"‚ùå {text}\")\n",
    "                return self\n",
    "            \n",
    "            def info(self, text):\n",
    "                print(f\"‚ÑπÔ∏è {text}\")\n",
    "                return self\n",
    "            \n",
    "            def set_page_config(self, **kwargs):\n",
    "                page_title = kwargs.get('page_title', 'App')\n",
    "                print(f\"üè† Configurando p√°gina: {page_title}\")\n",
    "                return self\n",
    "            \n",
    "            def __getattr__(self, name):\n",
    "                # Para cualquier m√©todo no implementado\n",
    "                def generic_method(*args, **kwargs):\n",
    "                    if args:\n",
    "                        print(f\"üîß [{name.upper()}]: {args[0]}\")\n",
    "                    return self\n",
    "                return generic_method\n",
    "        \n",
    "        return NotebookStreamlitWrapper()\n",
    "    \n",
    "    def _create_basic_wrapper(self):\n",
    "        \"\"\"Wrapper b√°sico silencioso\"\"\"\n",
    "        class BasicWrapper:\n",
    "            def __init__(self):\n",
    "                self.session_state = {}\n",
    "            \n",
    "            def __getattr__(self, name):\n",
    "                def dummy(*args, **kwargs):\n",
    "                    return self\n",
    "                return dummy\n",
    "        \n",
    "        return BasicWrapper()\n",
    "    \n",
    "    def _create_mock_streamlit(self):\n",
    "        \"\"\"Mock completo de Streamlit\"\"\"\n",
    "        class MockStreamlit:\n",
    "            def __init__(self):\n",
    "                self.session_state = {}\n",
    "            \n",
    "            def __getattr__(self, name):\n",
    "                def mock_function(*args, **kwargs):\n",
    "                    return self\n",
    "                return mock_function\n",
    "        \n",
    "        return MockStreamlit()\n",
    "\n",
    "# Inicializar manager de Streamlit\n",
    "streamlit_manager = StreamlitSafeManager()\n",
    "st = streamlit_manager.st\n",
    "\n",
    "print(f\"‚úÖ Streamlit manager inicializado (disponible: {streamlit_manager.available})\")\n",
    "\n",
    "# ===============================================================================\n",
    "# IMPORTS DE MACHINE LEARNING - OPCIONALES\n",
    "# ===============================================================================\n",
    "\n",
    "try:\n",
    "    from sklearn.model_selection import train_test_split\n",
    "    from sklearn.preprocessing import StandardScaler\n",
    "    from sklearn.linear_model import LinearRegression\n",
    "    from sklearn.ensemble import RandomForestRegressor\n",
    "    from sklearn.metrics import mean_squared_error, r2_score\n",
    "    from scipy import stats\n",
    "    ML_AVAILABLE = True\n",
    "    print(\"‚úÖ Librer√≠as de ML cargadas\")\n",
    "except ImportError as e:\n",
    "    ML_AVAILABLE = False\n",
    "    print(f\"‚ö†Ô∏è Algunas librer√≠as de ML no disponibles: {e}\")\n",
    "\n",
    "# ===============================================================================\n",
    "# CONFIGURACI√ìN DEL PROYECTO - PATHS SEGUROS\n",
    "# ===============================================================================\n",
    "\n",
    "# Detectar directorio actual de forma segura\n",
    "try:\n",
    "    current_path = Path.cwd()\n",
    "    PROJECT_ROOT = current_path.parent if 'notebooks' in current_path.parts else current_path\n",
    "    \n",
    "    # Directorios del proyecto\n",
    "    NOTEBOOKS_DIR = PROJECT_ROOT / 'notebooks'\n",
    "    SRC_DIR = PROJECT_ROOT / 'src'\n",
    "    DATA_DIR = PROJECT_ROOT / 'data'\n",
    "    DOCS_DIR = PROJECT_ROOT / 'docs'\n",
    "    TESTS_DIR = PROJECT_ROOT / 'tests'\n",
    "    \n",
    "    # Crear directorios si no existen (solo si tenemos permisos)\n",
    "    for directory in [SRC_DIR, DATA_DIR, DOCS_DIR, TESTS_DIR]:\n",
    "        try:\n",
    "            directory.mkdir(exist_ok=True)\n",
    "            # Crear __init__.py solo si es necesario\n",
    "            init_file = directory / '__init__.py'\n",
    "            if not init_file.exists() and directory.name == 'src':\n",
    "                init_file.touch()\n",
    "        except PermissionError:\n",
    "            print(f\"‚ö†Ô∏è Sin permisos para crear {directory}\")\n",
    "    \n",
    "    # A√±adir al path de forma segura\n",
    "    for path in [PROJECT_ROOT, SRC_DIR]:\n",
    "        path_str = str(path)\n",
    "        if path_str not in sys.path and path.exists():\n",
    "            sys.path.insert(0, path_str)\n",
    "    \n",
    "    print(f\"üìÅ Directorio del proyecto: {PROJECT_ROOT}\")\n",
    "    print(f\"üìÅ Notebooks: {'‚úÖ' if NOTEBOOKS_DIR.exists() else '‚ùå'}\")\n",
    "    print(f\"üìÅ C√≥digo fuente: {'‚úÖ' if SRC_DIR.exists() else '‚ùå'}\")\n",
    "    print(f\"üìÅ Datos: {'‚úÖ' if DATA_DIR.exists() else '‚ùå'}\")\n",
    "    \n",
    "except Exception as e:\n",
    "    print(f\"‚ö†Ô∏è Error configurando directorios: {e}\")\n",
    "    # Configuraci√≥n m√≠nima de respaldo\n",
    "    PROJECT_ROOT = Path.cwd()\n",
    "    DATA_DIR = PROJECT_ROOT / 'data'\n",
    "    DATA_DIR.mkdir(exist_ok=True)\n",
    "\n",
    "# ===============================================================================\n",
    "# CONFIGURACI√ìN ESPEC√çFICA DE QUILLOTA\n",
    "# ===============================================================================\n",
    "\n",
    "QUILLOTA_CONFIG = {\n",
    "    'ubicacion': {\n",
    "        'nombre': 'Quillota',\n",
    "        'region': 'Valpara√≠so',\n",
    "        'pais': 'Chile',\n",
    "        'latitud': -32.8833,\n",
    "        'longitud': -71.25,\n",
    "        'elevacion': 120,\n",
    "        'zona_horaria': 'America/Santiago'\n",
    "    },\n",
    "    \n",
    "    'clima': {\n",
    "        'tipo': 'Mediterr√°neo c√°lido',\n",
    "        'temperatura_media_anual': 16.5,\n",
    "        'precipitacion_anual_promedio': 400,\n",
    "        'meses_secos': [11, 12, 1, 2, 3],\n",
    "        'meses_lluviosos': [5, 6, 7, 8]\n",
    "    },\n",
    "    \n",
    "    'agricultura': {\n",
    "        'cultivos_principales': ['paltas', 'citricos', 'uvas', 'hortalizas'],\n",
    "        'temporada_crecimiento': {'inicio': 9, 'fin': 4},\n",
    "        'riego': {\n",
    "            'sistema_principal': 'goteo',\n",
    "            'fuente_agua': ['Rio Aconcagua', 'Pozos']\n",
    "        }\n",
    "    },\n",
    "    \n",
    "    'riesgos_climaticos': {\n",
    "        'heladas': 'Mayo a Septiembre',\n",
    "        'sequias': 'Diciembre a Marzo',\n",
    "        'vientos_fuertes': 'Agosto a Octubre'\n",
    "    }\n",
    "}\n",
    "\n",
    "# Umbrales cr√≠ticos\n",
    "UMBRALES_CRITICOS = {\n",
    "    'temperatura': {\n",
    "        'helada_severa': -2,\n",
    "        'helada_moderada': 0,\n",
    "        'calor_extremo': 35,\n",
    "        'calor_alto': 30\n",
    "    },\n",
    "    'precipitacion': {\n",
    "        'sequia_dias': 30,\n",
    "        'lluvia_intensa': 20,\n",
    "        'lluvia_extrema': 50\n",
    "    },\n",
    "    'viento': {\n",
    "        'moderado': 15,\n",
    "        'fuerte': 25,\n",
    "        'muy_fuerte': 40\n",
    "    },\n",
    "    'humedad': {\n",
    "        'muy_baja': 30,\n",
    "        'muy_alta': 85\n",
    "    }\n",
    "}\n",
    "\n",
    "print(\"‚úÖ Configuraci√≥n de Quillota cargada\")\n",
    "\n",
    "# ===============================================================================\n",
    "# FUNCIONES UTILITARIAS REPARADAS\n",
    "# ===============================================================================\n",
    "\n",
    "def crear_datos_meteorologicos(dias=365):\n",
    "    \"\"\"Genera datos meteorol√≥gicos simulados para Quillota\"\"\"\n",
    "    try:\n",
    "        np.random.seed(42)\n",
    "        fechas = pd.date_range(start='2024-01-01', periods=dias, freq='D')\n",
    "        \n",
    "        datos = pd.DataFrame({\n",
    "            'fecha': fechas,\n",
    "            'temperatura_max': np.random.normal(22, 6, dias),\n",
    "            'temperatura_min': np.random.normal(10, 4, dias),\n",
    "            'humedad_relativa': np.clip(np.random.normal(65, 15, dias), 20, 95),\n",
    "            'precipitacion': np.random.exponential(0.8, dias),\n",
    "            'velocidad_viento': np.clip(np.random.normal(8, 3, dias), 0, 40),\n",
    "            'direccion_viento': np.random.choice(['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'], dias),\n",
    "            'presion_atmosferica': np.random.normal(1013, 8, dias),\n",
    "            'radiacion_solar': np.clip(np.random.normal(18, 6, dias), 0, 30)\n",
    "        })\n",
    "        \n",
    "        # Ajustes estacionales para Chile\n",
    "        for i, fecha in enumerate(datos['fecha']):\n",
    "            mes = fecha.month\n",
    "            if mes in [12, 1, 2]:  # Verano\n",
    "                datos.loc[i, 'temperatura_max'] += 8\n",
    "                datos.loc[i, 'temperatura_min'] += 5\n",
    "                datos.loc[i, 'precipitacion'] *= 0.2\n",
    "            elif mes in [6, 7, 8]:  # Invierno\n",
    "                datos.loc[i, 'temperatura_max'] -= 6\n",
    "                datos.loc[i, 'temperatura_min'] -= 4\n",
    "                datos.loc[i, 'precipitacion'] *= 2.5\n",
    "        \n",
    "        return datos\n",
    "        \n",
    "    except Exception as e:\n",
    "        print(f\"‚ùå Error generando datos: {e}\")\n",
    "        # Retornar datos m√≠nimos en caso de error\n",
    "        return pd.DataFrame({\n",
    "            'fecha': pd.date_range('2024-01-01', periods=7),\n",
    "            'temperatura_max': [20] * 7,\n",
    "            'temperatura_min': [10] * 7,\n",
    "            'humedad_relativa': [60] * 7,\n",
    "            'precipitacion': [0] * 7,\n",
    "            'velocidad_viento': [8] * 7,\n",
    "            'direccion_viento': ['W'] * 7,\n",
    "            'presion_atmosferica': [1013] * 7,\n",
    "            'radiacion_solar': [18] * 7\n",
    "        })\n",
    "\n",
    "def evaluar_alertas(datos_dia):\n",
    "    \"\"\"Eval√∫a alertas meteorol√≥gicas de forma segura\"\"\"\n",
    "    try:\n",
    "        alertas = []\n",
    "        \n",
    "        if datos_dia['temperatura_min'] <= UMBRALES_CRITICOS['temperatura']['helada_severa']:\n",
    "            alertas.append('üßä HELADA SEVERA - Proteger cultivos inmediatamente')\n",
    "        elif datos_dia['temperatura_min'] <= UMBRALES_CRITICOS['temperatura']['helada_moderada']:\n",
    "            alertas.append('‚ùÑÔ∏è RIESGO DE HELADA - Monitorear cultivos sensibles')\n",
    "        \n",
    "        if datos_dia['temperatura_max'] >= UMBRALES_CRITICOS['temperatura']['calor_extremo']:\n",
    "            alertas.append('üî• CALOR EXTREMO - Aumentar frecuencia de riego')\n",
    "        \n",
    "        if datos_dia['velocidad_viento'] >= UMBRALES_CRITICOS['viento']['fuerte']:\n",
    "            alertas.append('üí® VIENTO FUERTE - Revisar estructuras y sistemas de soporte')\n",
    "        \n",
    "        if datos_dia['precipitacion'] >= UMBRALES_CRITICOS['precipitacion']['lluvia_intensa']:\n",
    "            alertas.append('üåßÔ∏è LLUVIA INTENSA - Revisar sistemas de drenaje')\n",
    "        \n",
    "        if datos_dia['humedad_relativa'] <= UMBRALES_CRITICOS['humedad']['muy_baja']:\n",
    "            alertas.append('üèúÔ∏è HUMEDAD MUY BAJA - Considerar riego adicional')\n",
    "        elif datos_dia['humedad_relativa'] >= UMBRALES_CRITICOS['humedad']['muy_alta']:\n",
    "            alertas.append('üíß HUMEDAD MUY ALTA - Riesgo de enfermedades f√∫ngicas')\n",
    "        \n",
    "        return alertas if alertas else ['‚úÖ Condiciones clim√°ticas favorables']\n",
    "        \n",
    "    except Exception as e:\n",
    "        print(f\"‚ö†Ô∏è Error evaluando alertas: {e}\")\n",
    "        return ['‚ö†Ô∏è Error en evaluaci√≥n de alertas']\n",
    "\n",
    "def mostrar_resumen_sistema():\n",
    "    \"\"\"Muestra resumen completo del sistema de forma segura\"\"\"\n",
    "    try:\n",
    "        print(\"\\n\" + \"=\"*60)\n",
    "        print(\"üìã RESUMEN DEL SISTEMA MIP QUILLOTA\")\n",
    "        print(\"=\"*60)\n",
    "        print(f\"üåç Ubicaci√≥n: {QUILLOTA_CONFIG['ubicacion']['nombre']}, {QUILLOTA_CONFIG['ubicacion']['region']}\")\n",
    "        print(f\"üìç Coordenadas: {QUILLOTA_CONFIG['ubicacion']['latitud']}, {QUILLOTA_CONFIG['ubicacion']['longitud']}\")\n",
    "        print(f\"üå°Ô∏è Clima: {QUILLOTA_CONFIG['clima']['tipo']}\")\n",
    "        print(f\"üå± Cultivos: {', '.join(QUILLOTA_CONFIG['agricultura']['cultivos_principales'])}\")\n",
    "        print(f\"üíß Riego: {QUILLOTA_CONFIG['agricultura']['riego']['sistema_principal']}\")\n",
    "        print(f\"üñ•Ô∏è  Contexto: {EXECUTION_CONTEXT}\")\n",
    "        print(f\"üìä Streamlit: {'Disponible' if streamlit_manager.available else 'No disponible'}\")\n",
    "        print(f\"üìà Plotly: {'Disponible' if PLOTLY_AVAILABLE else 'No disponible'}\")\n",
    "        print(f\"ü§ñ ML: {'Disponible' if ML_AVAILABLE else 'No disponible'}\")\n",
    "        print(\"=\"*60)\n",
    "        \n",
    "        # Generar datos de prueba\n",
    "        datos_prueba = crear_datos_meteorologicos(30)\n",
    "        print(f\"‚úÖ Datos de prueba generados: {len(datos_prueba)} d√≠as\")\n",
    "        print(f\"üìà Temp m√°xima: {datos_prueba['temperatura_max'].max():.1f}¬∞C\")\n",
    "        print(f\"üìâ Temp m√≠nima: {datos_prueba['temperatura_min'].min():.1f}¬∞C\")\n",
    "        print(f\"üåßÔ∏è Precipitaci√≥n total: {datos_prueba['precipitacion'].sum():.1f} mm\")\n",
    "        \n",
    "        # Evaluar alertas del √∫ltimo d√≠a\n",
    "        ultimo_dia = datos_prueba.iloc[-1]\n",
    "        alertas_hoy = evaluar_alertas(ultimo_dia)\n",
    "        print(f\"\\nüö® ALERTAS DEL D√çA:\")\n",
    "        for alerta in alertas_hoy:\n",
    "            print(f\"   {alerta}\")\n",
    "        \n",
    "        return datos_prueba\n",
    "        \n",
    "    except Exception as e:\n",
    "        print(f\"‚ùå Error en resumen del sistema: {e}\")\n",
    "        return crear_datos_meteorologicos(7)  # Datos m√≠nimos\n",
    "\n",
    "# ===============================================================================\n",
    "# FUNCIONES ADICIONALES DE UTILIDAD\n",
    "# ===============================================================================\n",
    "\n",
    "def verificar_dependencias():\n",
    "    \"\"\"Verifica que todas las dependencias est√©n disponibles\"\"\"\n",
    "    dependencias = {\n",
    "        'pandas': 'pd' in globals(),\n",
    "        'numpy': 'np' in globals(),\n",
    "        'matplotlib': 'plt' in globals(),\n",
    "        'plotly': PLOTLY_AVAILABLE,\n",
    "        'streamlit': streamlit_manager.available,\n",
    "        'sklearn': ML_AVAILABLE\n",
    "    }\n",
    "    \n",
    "    print(\"\\nüîç VERIFICACI√ìN DE DEPENDENCIAS:\")\n",
    "    for dep, disponible in dependencias.items():\n",
    "        estado = \"‚úÖ\" if disponible else \"‚ùå\"\n",
    "        print(f\"   {estado} {dep}\")\n",
    "    \n",
    "    return dependencias\n",
    "\n",
    "def crear_estructura_directorios():\n",
    "    \"\"\"Crea la estructura de directorios del proyecto si no existe\"\"\"\n",
    "    directorios = {\n",
    "        'notebooks': NOTEBOOKS_DIR if 'NOTEBOOKS_DIR' in globals() else Path('notebooks'),\n",
    "        'src': SRC_DIR if 'SRC_DIR' in globals() else Path('src'),\n",
    "        'data': DATA_DIR if 'DATA_DIR' in globals() else Path('data'),\n",
    "        'docs': DOCS_DIR if 'DOCS_DIR' in globals() else Path('docs'),\n",
    "        'tests': TESTS_DIR if 'TESTS_DIR' in globals() else Path('tests')\n",
    "    }\n",
    "    \n",
    "    print(\"\\nüìÅ CREANDO ESTRUCTURA DE DIRECTORIOS:\")\n",
    "    for nombre, directorio in directorios.items():\n",
    "        try:\n",
    "            directorio.mkdir(exist_ok=True)\n",
    "            print(f\"   ‚úÖ {nombre}: {directorio}\")\n",
    "            \n",
    "            # Crear subdirectorios espec√≠ficos\n",
    "            if nombre == 'data':\n",
    "                for subdir in ['raw', 'processed', 'external']:\n",
    "                    (directorio / subdir).mkdir(exist_ok=True)\n",
    "            elif nombre == 'src':\n",
    "                for subdir in ['data_processing', 'models', 'visualization', 'utils']:\n",
    "                    (directorio / subdir).mkdir(exist_ok=True)\n",
    "                    # Crear __init__.py\n",
    "                    (directorio / subdir / '__init__.py').touch()\n",
    "            elif nombre == 'tests':\n",
    "                for subdir in ['unit', 'integration']:\n",
    "                    (directorio / subdir).mkdir(exist_ok=True)\n",
    "                    \n",
    "        except Exception as e:\n",
    "            print(f\"   ‚ùå {nombre}: Error - {e}\")\n",
    "\n",
    "# ===============================================================================\n",
    "# VERIFICACI√ìN FINAL Y MENSAJE DE √âXITO\n",
    "# ===============================================================================\n",
    "\n",
    "print(\"\\nüéâ ¬°Sistema MIP Quillota configurado exitosamente!\")\n",
    "print(\"üîß Configuraci√≥n reparada y optimizada\")\n",
    "print(\"üìö Todos los imports manejados de forma segura\")\n",
    "print(\"‚öôÔ∏è Funciones utilitarias disponibles\")\n",
    "\n",
    "# Verificar dependencias autom√°ticamente\n",
    "deps_disponibles = verificar_dependencias()\n",
    "\n",
    "# Mostrar resumen autom√°ticamente\n",
    "datos_sistema = mostrar_resumen_sistema()\n",
    "\n",
    "# Crear estructura de directorios si es necesario\n",
    "try:\n",
    "    crear_estructura_directorios()\n",
    "except Exception as e:\n",
    "    print(f\"‚ö†Ô∏è No se pudo crear estructura completa: {e}\")\n",
    "\n",
    "print(\"\\nüöÄ Configuraci√≥n completa - Sistema listo para usar\")\n",
    "print(\"üìñ Este archivo puede ser importado por otros notebooks\")\n",
    "print(\"üîó Use %run para ejecutar desde otros notebooks\")\n",
    "\n",
    "# Variables globales disponibles para otros notebooks\n",
    "__all__ = [\n",
    "    'QUILLOTA_CONFIG',\n",
    "    'UMBRALES_CRITICOS', \n",
    "    'st',\n",
    "    'streamlit_manager',\n",
    "    'crear_datos_meteorologicos',\n",
    "    'evaluar_alertas',\n",
    "    'mostrar_resumen_sistema',\n",
    "    'EXECUTION_CONTEXT',\n",
    "    'PLOTLY_AVAILABLE',\n",
    "    'ML_AVAILABLE'\n",
    "]\n",
    "\n",
    "print(f\"\\nüìã Variables disponibles: {len(__all__)} elementos exportados\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
